package task

type ddynamic struct {
	count int
	name  string
	en    []string
	tj    []string
	ru    []string
}

func NewDynamicTask() Task {
	d := &ddynamic{
		count: 81,
		name:  "Dynamic",
	}
	d.makeEn()
	d.makeTj()
	d.makeRu()
	return d
}

func (d *ddynamic) Count() int   { return d.count }
func (d *ddynamic) Name() string { return d.name }
func (d *ddynamic) En() []string { return d.en }
func (d *ddynamic) Tj() []string { return d.tj }
func (d *ddynamic) Ru() []string { return d.ru }

func (d *ddynamic) makeEn() {
	d.en = make([]string, d.count)
	d.en[1] = `An address&nbsp;<i>P</i><sub>1</sub> of a record of TNode type is given. The record consists of the <i>Data</i> field (of integer type) and the <i>Next</i> field (of PNode type that refers to a variable of TNode type). The given record is linked by its <i>Next</i> field with the next record of the same type. Output the value of the <i>Data</i> field for each record and the address&nbsp;<i>P</i><sub>2</sub> of the record that follows the given one.`
	d.en[2] = `An address&nbsp;<i>P</i><sub>1</sub> of a record of TNode type is given. The record is linked by its <i>Next</i> field with the next record of the same type, that record is linked with the next one, and so on, until the last record whose <i>Next</i> field equals NULL (as a result, we obtain a <i>chain</i> of linked records). Output the value of the <i>Data</i> field for each chain component, the chain <i>length</i> (that is, the amount of its components) and the address of the last chain component.`
	d.en[3] = `An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack are given. Push a component with the value&nbsp;<i>D</i> onto the stack and output the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack.`
	d.en[4] = `An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Create a stack that contains <i>N</i>&nbsp;components with the given values (a component with the last value must be the top of the stack) and output a pointer to the top of the stack.`
	d.en[5] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack is given. Pop the top component off the stack and output its value&nbsp;<i>D</i> and the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack. If the stack will be empty after popping the component then&nbsp;<i>P</i><sub>2</sub> must be equal to NULL. After popping the component release the memory allocated for this component.`
	d.en[6] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given; the stack contains at least ten components. Pop the first nine components off the stack and output their values and the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack. After popping components release the memory allocated for these components.`
	d.en[7] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given (if the stack is empty then&nbsp;<i>P</i><sub>1</sub> equals NULL). Pop all components off the stack and output their values. Also output the amount of popped components (if the stack is empty then output&nbsp;0). After popping components release the memory allocated for these components.`
	d.en[8] = `Two pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> that refer to the tops of two nonempty stacks are given. Move all components from the first stack into the second one (as a result, all components of the first stack will be contained within the second stack in inverse order). Output the address of a new top of the second stack. Do not use operations of allocating and freeing memory.`
	d.en[9] = `Two pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> that refer to the tops of two nonempty stacks are given. Move components from the first stack into the second one until the value of the top component of the first stack is equal to an even number (as a result, all components having been moved will be contained within the second stack in inverse order). If the first stack contains no components with even values then move all its components. Output the address of a new top for each stack (if the first stack will be empty then output NULL for this stack). Do not use operations of allocating and freeing memory.`
	d.en[10] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack is given. Create two new stacks by moving the given stack components whose values are even (odd) numbers into the first (second) new stack respectively. As a result, all components having been moved will be contained within each new stack in inverse order; one of the new stacks may be empty. Output the address of the top for each new stack (if one of the new stacks will be empty then output NULL for this stack). Do not use operations of allocating and freeing memory.`
	d.en[11] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given (if the stack is empty then&nbsp;<i>P</i><sub>1</sub> equals NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TStack that is a record with one field, <i>Top</i>, of PNode type (the field refers to the top of a stack). Also write a procedure Push(<i>S</i>,&nbsp;<i>D</i>) that pushes a new component with the value&nbsp;<i>D</i> onto a stack&nbsp;<i>S</i> (a record&nbsp;<i>S</i> of TStack type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). Using this procedure, push all elements of the given sequence onto the given stack (the last number must be the value of the top component). Output the address of a new top of the stack.`
	d.en[12] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given; the stack contains at least five components. Using the TStack type (see Dynamic11), write an integer function Pop(<i>S</i>) that pops the top component off a stack&nbsp;<i>S</i>, releases memory allocated for this component and returns its value (a record&nbsp;<i>S</i> of TStack type is an input and output parameter). Using this function, pop five components off the given stack and output their values. Also output a pointer that refers to a new top of the stack (if the stack will be empty then this pointer must be equal to NULL).`
	d.en[13] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given. Using the TStack type (see Dynamic11), write two functions: a logical function StackIsEmpty(<i>S</i>) that returns true if a stack&nbsp;<i>S</i> is empty, and false otherwise, and an integer function Peek(<i>S</i>) that returns the value of the top component of the stack&nbsp;<i>S</i>. A record&nbsp;<i>S</i> of TStack type is an input parameter for each function. Using these functions and the Pop function from the task Dynamic12, pop five components (or all stack components if their amount is less than five) off the given stack and output their values. Also output the return value of the StackIsEmpty function for the resulting stack. At last, in the case of the nonempty resulting stack, output the value and the address of its top component.`
	d.en[14] = `A sequence of 10&nbsp;integers is given. Create a queue that contains components with the given values (a component with the first value must be the head of the queue, a component with the last value must be the tail of the queue) and output pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of the queue respectively.`
	d.en[15] = `A sequence of 10&nbsp;integers is given. Create two queues; the first one must contain the given integers with odd order numbers (1, 3,&nbsp;&#8230;, 9), the second one must contain the given integers with even order numbers (2, 4,&nbsp;&#8230;, 10). Output pointers to the head and tail of the first queue and then output pointers to the head and tail of the second one.`
	d.en[16] = `A sequence of 10&nbsp;integers is given. Create two queues; the first one must contain the given integers with odd values (in the same order), the second one must contain the given integers with even values (in the same order). Output pointers to the head and tail of the first queue and then output pointers to the head and tail of the second one (if one of the queues will be empty then output NULL twice for this queue).`
	d.en[17] = `An integer&nbsp;<i>D</i> and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given (if the queue is empty then the pointers equal NULL). Add a component with the value&nbsp;<i>D</i> to the end of the queue and output the new addresses of the head and tail of the queue.`
	d.en[18] = `An integer&nbsp;<i>D</i> and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given; the queue contains at least two components. Add a component with the value&nbsp;<i>D</i> to the end of the queue and remove the first component from the front of the queue. Output the value of the component being removed and also output the new addresses of the head and tail of the queue. After removing the component release the memory allocated for this component.`
	d.en[19] = `An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a nonempty queue are given. Remove <i>N</i>&nbsp;initial components from the queue and output their values (if the queue contains less than <i>N</i>&nbsp;components then remove all its components). Also output the new addresses of the head and tail of the queue (if the resulting queue will be empty then output NULL twice). After removing components release the memory allocated for them.`
	d.en[20] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a nonempty queue are given. Remove components from the front of the queue until the value of the head of the queue is equal to an even number; output values of all components being removed (if the queue contains no components with even values then remove all its components). Also output the new addresses of the head and tail of the queue (if the resulting queue will be empty then output NULL twice). After removing components release the memory allocated for them.`
	d.en[21] = `Two queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one (if some queue is empty then the corresponding pointers equal NULL). Move all components from the first queue (starting with its first component) to the end of the second one. Output the new addresses of the head and tail of the second queue. Do not use operations of allocating and freeing memory.`
	d.en[22] = `An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. Move <i>N</i>&nbsp;initial components of the first queue to the end of the second one (if the first queue contains less than <i>N</i>&nbsp;components then move all its components). Output the new addresses of the head and tail of the first queue and then output the new addresses of the head and tail of the second one (if the first queue will be empty then output NULL twice for this queue). Do not use operations of allocating and freeing memory.`
	d.en[23] = `Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. Move initial components of the first queue to the end of the second one until the value of the head of the first queue is equal to an even number (if the first queue contains no components with even values then move all its components). Output the new addresses of the head and tail of the first queue and then output the new addresses of the head and tail of the second one (if the first queue will be empty then output NULL twice for this queue). Do not use operations of allocating and freeing memory.`
	d.en[24] = `Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. The queues contain the equal amount of components. Combine the given queues into a new one; the resulting queue must contain alternating components of the given queues starting with the head of the first one. Output pointers to the head and tail of the resulting queue. Do not use operations of allocating and freeing memory.`
	d.en[25] = `Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. The values of components of each given queue are in ascending order. Combine the given queues into a new one; the values of components of the resulting queue must be in ascending order too. Output pointers to the head and tail of the resulting queue. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[26] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given (if the queue is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TQueue that is a record with two fields, <i>Head</i> and <i>Tail</i>, of PNode type (the fields refer to the head and tail of a queue respectively). Also write a procedure Enqueue(<i>Q</i>,&nbsp;<i>D</i>) that adds a new component with the value&nbsp;<i>D</i> to the end of a queue&nbsp;<i>Q</i> (a record&nbsp;<i>Q</i> of TQueue type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). Using this procedure, add all elements of the given sequence to the end of the given queue. Output the new addresses of the head and tail of the queue.`
	d.en[27] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given; the queue contains at least five components. Using the TQueue type (see Dynamic26), write an integer function Dequeue(<i>Q</i>) that removes the first component from the front of a queue&nbsp;<i>Q</i>, releases memory allocated for this component and returns its value (a record&nbsp;<i>Q</i> of TQueue type is an input and output parameter). Using this function, remove five initial components from the front of the given queue and output their values. Also output the new addresses of the head and tail of the queue (if the queue will be empty then output NULL twice).`
	d.en[28] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given. Using the TQueue type (see Dynamic26), write a logical function QueueIsEmpty(<i>Q</i>) that returns true if a queue&nbsp;<i>Q</i> is empty, and false otherwise (a record&nbsp;<i>Q</i> of TQueue type is an input parameter). Using this function and also the Dequeue function from the task Dynamic27, remove five initial components (or all queue components if their amount is less than five) from the front of the given queue and output their values. Also output the return value of the QueueIsEmpty function for the resulting queue and the new addresses of the head and tail of this queue (if the queue will be empty then output NULL twice).`
	d.en[29] = `An address&nbsp;<i>P</i><sub>2</sub> of a record of TNode type is given. The record consists of the following fields: <i>Data</i> (of integer type), <i>Prev</i>, <i>Next</i> (each of PNode type that refers to a variable of TNode type). The given record is linked by its <i>Prev</i> and <i>Next</i> field with the previous and next record of the same type respectively. Output the values of the <i>Data</i> field for the previous and next record, and also output the addresses&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>3</sub> of these records.`
	d.en[30] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the beginning of a chain of records is given; the records have TNode type and are linked by their <i>Next</i> fields. Using the <i>Prev</i> field of the TNode record, transform the given (<i>singly linked</i>) chain into the <i>doubly linked</i> chain whose components are linked not only with the next ones (by the <i>Next</i> field) but also with the previous ones (by the <i>Prev</i> field). The <i>Prev</i> field of the first chain component must be equal to NULL. Output the address of the last component of the resulting chain.`
	d.en[31] = `A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Output the amount&nbsp;<i>N</i> of the list components and also pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component respectively.`
	d.en[32] = `Two integers&nbsp;<i>D</i><sub>1</sub>, <i>D</i><sub>2</sub> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i><sub>1</sub> at the beginning of the list; insert a new component with the value&nbsp;<i>D</i><sub>2</sub> at the end of the list. Output the addresses of the first and last list component.`
	d.en[33] = `An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i> before the given list component. Output the address of the component being inserted.`
	d.en[34] = `An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i> after the given list component. Output the address of the component being inserted.`
	d.en[35] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The list contains at least two components. Double occurrences of the first and last list component (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.`
	d.en[36] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The list contains at least two components. Double occurrences of the first and last list component (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.`
	d.en[37] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd order numbers (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.`
	d.en[38] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd order numbers (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.`
	d.en[39] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd values (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.`
	d.en[40] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd values (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.`
	d.en[41] = `A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Remove this component from the list and output the addresses of its previous and next component in the list (one or both these components may be absent; output NULL for each absent component). After removing the component release the memory allocated for this component.`
	d.en[42] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a doubly linked list is given. The list contains at least two components. Remove all components with odd order numbers from the list and output the address of the first component of the resulting list. After removing components release the memory allocated for them.`
	d.en[43] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Remove all components with odd values from the list and output the address of the first component of the resulting list (if this list will be empty then output NULL). After removing components release the memory allocated for them.`
	d.en[44] = `A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Move this component to the end of the list and output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[45] = `A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Move this component to the beginning of the list and output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[46] = `An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Move this component by <i>K</i>&nbsp;positions forward in the list (if the list contains less than <i>K</i>&nbsp;components after the given component then move it to the end of the list). Output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[47] = `An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Move this component by <i>K</i>&nbsp;positions backward in the list (if the list contains less than <i>K</i>&nbsp;components before the given component then move it to the beginning of the list). Output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[48] = `Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Exchange the given components in the list and output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[49] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Rearrange list components by moving all components with odd order numbers to the end of the list (in the same order). Output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[50] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Rearrange list components by moving all components with odd values to the end of the list (in the same order). Output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.`
	d.en[51] = `Two nonempty doubly linked lists are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the first and last component of the first list, a pointer&nbsp;<i>P</i><sub>0</sub> refers to one of the components of the second list. Combine the given lists by inserting all components of the first list (in the same order) before the given component of the second list. Output the addresses of the first and last component of the combined list. Do not use operations of allocating and freeing memory.`
	d.en[52] = `Two nonempty doubly linked lists are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the first and last component of the first list, a pointer&nbsp;<i>P</i><sub>0</sub> refers to one of the components of the second list. Combine the given lists by inserting all components of the first list (in the same order) after the given component of the second list. Output the addresses of the first and last component of the combined list. Do not use operations of allocating and freeing memory.`
	d.en[53] = `Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Move list components that are located between the given components (including these components) to a new list (in the same order). Output the addresses of the first components of the changed and new list. If the changed list will be empty then output NULL for this list. Do not use operations of allocating and freeing memory.`
	d.en[54] = `Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Move list components that are located between the given components (not including these components) to a new list (in the same order). Output the addresses of the first components of the changed and new list. If the new list will be empty then output NULL for this list. Do not use operations of allocating and freeing memory.`
	d.en[55] = `A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Transform this list to the <i>circular</i> one by assigning the address of the first component to the <i>Next</i> field of the last component and the address of the last component to the <i>Prev</i> field of the first component. Output the address of the component that has been the last component of the given list.`
	d.en[56] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The amount of list components is an even number. Split the list into two <i>circular</i> lists (see Dynamic55); the first (second) resulting list must contain the first (second) half of components of the given list respectively. Output the pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> to two middle components of the given list; the component with the address&nbsp;<i>P</i><sub>3</sub> must be contained in the first resulting circular list, the component with the address&nbsp;<i>P</i><sub>4</sub> must be contained in the second one. Do not use operations of allocating and freeing memory.`
	d.en[57] = `An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a nonempty doubly linked list are given. Perform a <i>cyclic shift</i> of all list components by <i>K</i>&nbsp;positions forward (that is, from the beginning toward the end of the list). Output the addresses of the first and last component of the resulting list. The required shift should be performed as follows: transform the given list to the circular one (see Dynamic55) and then break this circular list at the position that corresponds to the given value of&nbsp;<i>K</i>. Do not use operations of allocating and freeing memory.`
	d.en[58] = `An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a nonempty doubly linked list are given. Perform a <i>cyclic shift</i> of all list components by <i>K</i>&nbsp;positions backward (that is, from the end toward the beginning of the list). Output the addresses of the first and last component of the resulting list. The required shift should be performed as follows: transform the given list to the circular one (see Dynamic55) and then break this circular list at the position that corresponds to the given value of&nbsp;<i>K</i>. Do not use operations of allocating and freeing memory.`
	d.en[59] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given (if the list is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TList that is a record with three fields&#8212;<i>First</i>, <i>Last</i>, <i>Current</i>&#8212;of PNode type (the fields refer to the <i>first</i>, <i>last</i>, and <i>current</i> component of a doubly linked list respectively). Also write a procedure InsertLast(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the end of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the end of the given list (in the same order). Output the new addresses of the first, last, and current component of the resulting list.`
	d.en[60] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given (if the list is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Using the TList type (see Dynamic59), write a procedure InsertFirst(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the beginning of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the beginning of the given list (a component with the last value must be the first component of the resulting list). Output the new addresses of the first, last, and current component of the resulting list.`
	d.en[61] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list and five integers are given. Using the TList type (see Dynamic59), write a procedure InsertBefore(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> before the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new addresses of the first, last, and current component of the resulting list.`
	d.en[62] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list and five integers are given. Using the TList type (see Dynamic59), write a procedure InsertAfter(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> after the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new addresses of the first, last, and current component of the resulting list.`
	d.en[63] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write three procedures: a procedure ToFirst(<i>L</i>) makes the first component of a list&nbsp;<i>L</i> the current one; a procedure ToNext(<i>L</i>) makes the component, which follows the current component of a list&nbsp;<i>L</i>, the new current one (provided that such a component exists); a procedure SetData(<i>L</i>,&nbsp;<i>D</i>) assigns a new integer value&nbsp;<i>D</i> to the current component of a list&nbsp;<i>L</i>. Also write a logical function IsLast(<i>L</i>) that returns true if the current component of a list&nbsp;<i>L</i> is the last component, and false otherwise. A record&nbsp;<i>L</i> of TList type is an input and output parameter of the ToFirst and ToNext procedure and is an input parameter of the SetData procedure and the IsLast function. Using these procedures and function, assign zero value to the list components with odd order numbers. Output the amount of list components and also output addresses of the first, last, and current component of the resulting list (the current component should be the last one).`
	d.en[64] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write two procedures: a procedure ToLast(<i>L</i>) makes the last component of a list&nbsp;<i>L</i> the current one; a procedure ToPrev(<i>L</i>) makes the component, which precedes the current component of a list&nbsp;<i>L</i>, the new current one (provided that such a component exists). Also write two functions: an integer function GetData(<i>L</i>) returns the value of the current component of a list&nbsp;<i>L</i>; a logical function IsFirst(<i>L</i>) returns true if the current component of a list&nbsp;<i>L</i> is the first component, and false otherwise. A record&nbsp;<i>L</i> of TList type is an input and output parameter of the ToLast and ToPrev procedure and is an input parameter of the GetData and IsFirst function. Using these procedures and functions, browse all list components from the end toward the beginning of the list and output their values that are even numbers. Also output the amount of list components.`
	d.en[65] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given. The list contains at least five components. Using the TList type (see Dynamic59), write an integer function DeleteCurrent(<i>L</i>) that removes the current component of a list&nbsp;<i>L</i>, releases memory allocated for the component being removed, and returns the value of this component (a record&nbsp;<i>L</i> of TList type is an input and output parameter). If the next component of the list&nbsp;<i>L</i> exists then it becomes the new current component, otherwise the last component becomes the new current one. Using this function, remove five components from the given list and output their values. Also output the new addresses of the first, last, and current component of the resulting list (if the resulting list will be empty then output NULL three times).`
	d.en[66] = `Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write a procedure SplitList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that moves some components of a list&nbsp;<i>L</i><sub>1</sub> into a new list&nbsp;<i>L</i><sub>2</sub>: components between the current and last component inclusively must be moved (as a result, the list&nbsp;<i>L</i><sub>1</sub> will be split into two parts; the first part may be empty). A record&nbsp;<i>L</i><sub>1</sub> of TList type is an input and output parameter, a record&nbsp;<i>L</i><sub>2</sub> of the same type is an output parameter. The first component of each nonempty resulting list becomes the current component of this list. The procedure should not use operations of allocating and freeing memory. Using this procedure, split the given list into two lists and output the addresses of the first, last, and current component of each resulting list.`
	d.en[67] = `Pointers to the first, last, and current component of two nonempty doubly linked lists are given. Using the TList type (see Dynamic59), write a procedure AddList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that inserts all components of a list&nbsp;<i>L</i><sub>1</sub> (in the same order) at the end of a list&nbsp;<i>L</i><sub>2</sub>; as a result, the list&nbsp;<i>L</i><sub>1</sub> will be empty. The first component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, insert the first given list at the end of the second one and output the addresses of the first, last, and current component of the combined list.`
	d.en[68] = `Pointers to the first, last, and current component of two nonempty doubly linked lists are given. Using the TList type (see Dynamic59), write a procedure InsertList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that inserts all components of a list&nbsp;<i>L</i><sub>1</sub> (in the same order) before the current component of a list&nbsp;<i>L</i><sub>2</sub>; as a result, the list&nbsp;<i>L</i><sub>1</sub> will be empty. The first component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, insert the first given list before the current component of the second one and output the addresses of the first, last, and current component of the combined list.`
	d.en[69] = `Pointers to the first, last, and current component of two doubly linked lists are given; the second list may be empty. Using the TList type (see Dynamic59), write a procedure MoveCurrent(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that removes the current component from a list&nbsp;<i>L</i><sub>1</sub> and inserts this component after the current component of a list&nbsp;<i>L</i><sub>2</sub>. If the next component of the list&nbsp;<i>L</i><sub>1</sub> exists then it becomes the new current component of this list, otherwise the last component becomes the new current one; the component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, move the current component of the first given list into the second one and output the addresses of the first, last, and current component of each resulting list (if the first resulting list will be empty then output NULL three times for this list).`
	d.en[70] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given (a doubly linked list is implemented by a chain of linked nodes of TNode type, the <i>Prev</i> field of the first node and the <i>Next</i> field of the last node are equal to NULL); if the list is empty then the pointers equal NULL. Transform the given list into the circular list (see Dynamic55) with a <i>barrier component</i>. The barrier component has zero value and is linked with the first and last component of the given list by the <i>Next</i> and <i>Prev</i> field respectively (if the given list is empty then the <i>Next</i> and <i>Prev</i> field of the barrier component must refer to the barrier component itself). Output the address of the barrier component of the resulting list. Use the operation of allocating memory only for creation of the barrier component.`
	d.en[71] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given (see the <i>barrier component</i> definition in Dynamic70). Move the given list components that are between the current and last component (inclusively) to a new list with the barrier component. If the current component of the given list is its barrier component then the new list must be empty (that is, it must contain the barrier component only). Output the address of the barrier component of the new list. Use the operation of allocating memory only for creation of the barrier component of the new list.`
	d.en[72] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier components of two doubly linked lists are given (see the <i>barrier component</i> definition in Dynamic70). Combine the given lists by linking the last component of the first list with the first component of the second list. Use the barrier component of the first list as the barrier component of the combined list. Output the addresses of the first and last component of the combined list (if the combined list will be empty then output the address of its barrier component twice). After removing the superfluous barrier component (of the second list) release the memory allocated for this component.`
	d.en[73] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier components of two doubly linked lists are given (see the <i>barrier component</i> definition in Dynamic70). Combine the given lists by linking the last component of the first list with the first component of the second list. Use the barrier component of the second list as the barrier component of the combined list. Output the addresses of the first and last component of the combined list (if the combined list will be empty then output the address of its barrier component twice). After removing the superfluous barrier component (of the first list) release the memory allocated for this component.`
	d.en[74] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given (see the <i>barrier component</i> definition in Dynamic70). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TListB that is a record with two fields, <i>Barrier</i> and <i>Current</i>, of PNode type (the fields refer to the <i>barrier</i> and <i>current</i> component of a doubly linked list respectively). Also write a procedure LBInsertLast(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the end of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the end of the given list (in the same order). Output the new address of the current component of the resulting list.`
	d.en[75] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertFirst(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the beginning of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the beginning of the given list (a component with the last value must be the first component of the resulting list). Output the new address of the current component of the resulting list.`
	d.en[76] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list and five integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertBefore(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> before the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new address of the current component of the resulting list.`
	d.en[77] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list and five integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertAfter(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> after the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new address of the current component of the resulting list.`
	d.en[78] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Using the TListB type (see Dynamic74), write three procedures: a procedure LBToFirst(<i>L</i>) makes the first component of a list&nbsp;<i>L</i> the current one; a procedure LBToNext(<i>L</i>) makes the component, which follows the current component of a list&nbsp;<i>L</i>, the new current one; a procedure LBSetData(<i>L</i>,&nbsp;<i>D</i>) assigns a new integer value&nbsp;<i>D</i> to the current component of a list&nbsp;<i>L</i> (provided that the current component is not the barrier one). Also write a logical function IsBarrier(<i>L</i>) that returns true if the current component of a list&nbsp;<i>L</i> is the barrier component, and false otherwise. A record&nbsp;<i>L</i> of TListB type is an input and output parameter of the LBToFirst and LBToNext procedure and is an input parameter of the LBSetData procedure and the IsBarrier function. Using these procedures and function, assign zero value to the list components with odd order numbers. Output the amount of list components and the address of the current component of the resulting list (the current component should be the barrier one). The components are numbered from the first component, which has the order number&nbsp;1; the barrier component is not numbered and should not be counted.`
	d.en[79] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Using the TListB type (see Dynamic74), write two procedures: a procedure LBToLast(<i>L</i>) makes the last component of a list&nbsp;<i>L</i> the current one; a procedure LBToPrev(<i>L</i>) makes the component, which precedes the current component of a list&nbsp;<i>L</i>, the new current one. Also write an integer function LBGetData(<i>L</i>) that returns the value of the current component of a list&nbsp;<i>L</i>. A record&nbsp;<i>L</i> of TListB type is an input and output parameter of the LBToLast and LBToPrev procedure and is an input parameter of the LBGetData function. Using these procedures and function and also the IsBarrier function from the task Dynamic78, browse all list components from the end toward the beginning of the list and output their values that are even numbers. Also output the amount of list components. The barrier component should not be processed and counted.`
	d.en[80] = `Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a nonempty doubly linked list are given; the current component is not the barrier one. Using the TListB type (see Dynamic74), write an integer function LBDeleteCurrent(<i>L</i>) that removes the current component of a list&nbsp;<i>L</i>, releases memory allocated for the component being removed, and returns the value of this component (a record&nbsp;<i>L</i> of TListB type is an input and output parameter). If the next component of the list&nbsp;<i>L</i> is not the barrier one then it becomes the new current component, otherwise the previous component becomes the new current one. If the current component is the barrier one then the function performs no actions and returns&nbsp;0. Using this function and also the IsBarrier function from the task Dynamic78, remove five components from the given list (or all components if their amount is less than five) and output their values. Also output the new address of the current component of the resulting list.`
}

func (d *ddynamic) makeTj() {
	d.tj = make([]string, d.count)
}

func (d *ddynamic) makeRu() {
	d.ru = make([]string, d.count)
	d.ru[1] = ` &nbsp;<i>P</i><sub>1</sub>   TNode,   Data ( )   Next ( PNode &#8212;   TNode).     Next      .    Data  ,   &nbsp;<i>P</i><sub>2</sub>  .`
	d.ru[2] = ` &nbsp;<i>P</i><sub>1</sub>   TNode.     Next      , ,   , &#8212;  ,     ,  Next   NULL ( ,  <i></i>  ).    Data    , <i> </i> (.&nbsp;.   )     .`
	d.ru[3] = ` &nbsp;<i>D</i>  &nbsp;<i>P</i><sub>1</sub>    .    &nbsp;<i>D</i>     &nbsp;<i>P</i><sub>2</sub>   .`
	d.ru[4] = ` &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.  ,    (    ),      .`
	d.ru[5] = ` &nbsp;<i>P</i><sub>1</sub>    .     ()     &nbsp;<i>D</i>,   &nbsp;<i>P</i><sub>2</sub>   .       ,   <i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL.       ,   .`
	d.ru[6] = ` &nbsp;<i>P</i><sub>1</sub>   ,     .          .      .       ,   .`
	d.ru[7] = ` &nbsp;<i>P</i><sub>1</sub>    (  ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;NULL).         .     &nbsp;<i>N</i> (   &nbsp;0).       ,   .`
	d.ru[8] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     .         (           ,  )       .       .`
	d.ru[9] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     .       ,         (          ,  ).         ,         .         (    ,      NULL).       .`
	d.ru[10] = ` &nbsp;<i>P</i><sub>1</sub>    .    ,            ,    &#8212;   (       ,  ;       ).      (   &nbsp;NULL).       .`
	d.ru[11] = ` &nbsp;<i>P</i><sub>1</sub>    (  ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;NULL).   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TStack &#8212;     Top  PNode (   <i></i> ) &#8212;   Push(<i>S</i>,&nbsp;<i>D</i>),    &nbsp;<i>S</i>    &nbsp;<i>D</i> (<i>S</i> &#8212;      TStack, <i>D</i> &#8212;    ).    Push        (    )      .`
	d.ru[12] = ` &nbsp;<i>P</i><sub>1</sub>   ,     .   TStack (.  Dynamic11),   Pop(<i>S</i>)  ,    &nbsp;<i>S</i>  () ,      ,     (<i>S</i> &#8212;      TStack).    Pop          .        (    ,      &nbsp;NULL).`
	d.ru[13] = ` &nbsp;<i>P</i><sub>1</sub>   .   TStack (.  Dynamic11),   StackIsEmpty(<i>S</i>)   ( true,  &nbsp;<i>S</i> ,  false   )  Peek(<i>S</i>)   (    &nbsp;<i>S</i>,     ).    &nbsp;<i>S</i>     TStack.    ,    Pop   Dynamic12,       (     ,    )    .     StackIsEmpty    ,      ,      .`
	d.ru[14] = `   10&nbsp;.  ,       (      ,  &#8212;  ),   &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     .`
	d.ru[15] = `   10&nbsp;.   :           (1, 3,&nbsp;&#8230;, 9),   &#8212;   (2, 4,&nbsp;&#8230;, 10);             .       ,    .`
	d.ru[16] = `   10&nbsp;.   :     ,   &#8212;       (            ).       ,     (     ;        &nbsp;NULL).`
	d.ru[17] = ` &nbsp;<i>D</i>  &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>      (   ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL).    &nbsp;<i>D</i>           .`
	d.ru[18] = ` &nbsp;<i>D</i>  &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     ,     .    &nbsp;<i>D</i>         () .           .       ,   .`
	d.ru[19] = ` &nbsp;<i>N</i> (&gt;&nbsp;0)  &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>      .    <i>N</i>&nbsp;      (    <i>N</i>&nbsp;,     ).         (     NULL).       ,   .`
	d.ru[20] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>      .    ,        ,      (       ,     ).         (     NULL).       ,   .`
	d.ru[21] = `  ;      &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>,   &#8212; <i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub> (   ,    &nbsp;NULL).      (     )             .       .`
	d.ru[22] = ` &nbsp;<i>N</i> (&gt;&nbsp;0)    ;       <i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>,   &#8212; <i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub>.  <i>N</i>&nbsp;       .      <i>N</i>&nbsp;,         .       ,     (    &nbsp;NULL).       .`
	d.ru[23] = `   ;      &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>,   &#8212; <i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub>.         ,          (      ,         ).       ,     (    &nbsp;NULL).       .`
	d.ru[24] = `   ;      &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>,   &#8212; <i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub>.     .    ,       (     ).        .       .`
	d.ru[25] = `   ;      &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>,   &#8212; <i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub>.        (      ).        .        .       ,  Data  .`
	d.ru[26] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>      (   ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL).   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TQueue &#8212;     Head  Tail  PNode (   <i></i>  <i></i> ) &#8212;   Enqueue(<i>Q</i>,&nbsp;<i>D</i>),     &nbsp;<i>Q</i>    &nbsp;<i>D</i> (<i>Q</i> &#8212;      TQueue, <i>D</i> &#8212;    ).    Enqueue               .`
	d.ru[27] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     ,     .   TQueue (.  Dynamic26),   Dequeue(<i>Q</i>)  ,      () ,      ,    (<i>Q</i> &#8212;      TQueue).    Dequeue           .         (   ,      &nbsp;NULL).`
	d.ru[28] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>     .   TQueue (.  Dynamic26),   QueueIsEmpty(<i>Q</i>)  ,   true,  &nbsp;<i>Q</i> ,  false    (<i>Q</i> &#8212;    TQueue).       ,    Dequeue   Dynamic27,        (     ,    )    .     QueueIsEmpty          .`
	d.ru[29] = `  <i>P</i><sub>2</sub>   TNode,   Data ( )   Prev  Next ( PNode &#8212;   TNode).     Prev  Next         .    Data    ,   &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>3</sub>    .`
	d.ru[30] = `  <i>P</i><sub>1</sub>     -  TNode,       Next.   Prev  TNode,   (<i></i>)   <i></i>,           (   Next),     (   Prev).  Prev    &nbsp;NULL.       .`
	d.ru[31] = ` &nbsp;<i>P</i><sub>0</sub>       .  &nbsp;<i>N</i> &#8212;    ,   &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>      .`
	d.ru[32] = ` &nbsp;<i>D</i><sub>1</sub> &nbsp;<i>D</i><sub>2</sub>  &nbsp;<i>P</i><sub>0</sub>       .        &nbsp;<i>D</i><sub>1</sub>,    &#8212;    &nbsp;<i>D</i><sub>2</sub>.        .`
	d.ru[33] = ` &nbsp;<i>D</i>  &nbsp;<i>P</i><sub>0</sub>       .         &nbsp;<i>D</i>       .`
	d.ru[34] = ` &nbsp;<i>D</i>  &nbsp;<i>P</i><sub>0</sub>       .         &nbsp;<i>D</i>       .`
	d.ru[35] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       ,     .        (         )        .`
	d.ru[36] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       ,     .        (         )        .`
	d.ru[37] = ` &nbsp;<i>P</i><sub>1</sub>      .         (         )        .`
	d.ru[38] = ` &nbsp;<i>P</i><sub>1</sub>      .         (         )        .`
	d.ru[39] = ` &nbsp;<i>P</i><sub>1</sub>      .         (         )        .`
	d.ru[40] = ` &nbsp;<i>P</i><sub>1</sub>      .         (         )        .`
	d.ru[41] = ` &nbsp;<i>P</i><sub>0</sub>       .         :  ,  ,   ,    (      ;    &nbsp;NULL).       ,   .`
	d.ru[42] = ` &nbsp;<i>P</i><sub>1</sub>     ,     .                .       ,   .`
	d.ru[43] = ` &nbsp;<i>P</i><sub>1</sub>      .                 (       ,  &nbsp;NULL).       ,   .`
	d.ru[44] = ` &nbsp;<i>P</i><sub>0</sub>       .                .       ,  Data  .`
	d.ru[45] = ` &nbsp;<i>P</i><sub>0</sub>       .                .       ,  Data  .`
	d.ru[46] = ` &nbsp;<i>K</i> (&gt;&nbsp;0)  &nbsp;<i>P</i><sub>0</sub>       .       <i>K</i>&nbsp;  (      <i>K</i>&nbsp;,      ).         .       ,  Data  .`
	d.ru[47] = ` &nbsp;<i>K</i> (&gt;&nbsp;0)  &nbsp;<i>P</i><sub>0</sub>       .       <i>K</i>&nbsp;  (      <i>K</i>&nbsp;,      ).         .       ,  Data  .`
	d.ru[48] = ` &nbsp;<i>P</i><sub><i>X</i></sub> &nbsp;<i>P</i><sub><i>Y</i></sub>       (  &nbsp;<i>P</i><sub><i>X</i></sub>       &nbsp;<i>P</i><sub><i>Y</i></sub>,      ).            .       ,  Data  .`
	d.ru[49] = ` &nbsp;<i>P</i><sub>1</sub>      .   ,          (   )        .       ,  Data  .`
	d.ru[50] = ` &nbsp;<i>P</i><sub>1</sub>      .   ,          (   )        .       ,  Data  .`
	d.ru[51] = `         :&nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        , <i>P</i><sub>0</sub> &#8212;     .   ,      (   )     ,          .       .`
	d.ru[52] = `         :&nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        , <i>P</i><sub>0</sub> &#8212;     .   ,      (   )     ,          .       .`
	d.ru[53] = ` &nbsp;<i>P</i><sub><i>X</i></sub> &nbsp;<i>P</i><sub><i>Y</i></sub>      ;   &nbsp;<i>P</i><sub><i>X</i></sub>       &nbsp;<i>P</i><sub><i>Y</i></sub>,      .  ,     (  ),    (   ).         .     ,       &nbsp;NULL.       .`
	d.ru[54] = ` &nbsp;<i>P</i><sub><i>X</i></sub> &nbsp;<i>P</i><sub><i>Y</i></sub>      ;   &nbsp;<i>P</i><sub><i>X</i></sub>       &nbsp;<i>P</i><sub><i>Y</i></sub>,      .  ,     (   ),    (   ).         .     ,       &nbsp;NULL.       .`
	d.ru[55] = ` &nbsp;<i>P</i><sub>1</sub>      .    <i></i>,    Next       ,    Prev   &#8212;   .    ,      .`
	d.ru[56] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        ,    .     <i></i>  (.  Dynamic55),         ,   &#8212;  .  &nbsp;<i>P</i><sub>3</sub> &nbsp;<i>P</i><sub>4</sub>       (  &nbsp;<i>P</i><sub>3</sub>      ,    &nbsp;<i>P</i><sub>4</sub> &#8212;  ).       .`
	d.ru[57] = ` &nbsp;<i>K</i> (&gt;&nbsp;0)  &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        .  <i> </i>    <i>K</i>&nbsp;  (.&nbsp;.       )          .          (.  Dynamic55),   &#171;&#187;   ,   &nbsp;<i>K</i>.       .`
	d.ru[58] = ` &nbsp;<i>K</i> (&gt;&nbsp;0)  &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        .  <i> </i>    <i>K</i>&nbsp;  (.&nbsp;.       )          .          (.  Dynamic55),   &#171;&#187;   ,   &nbsp;<i>K</i>.       .`
	d.ru[59] = ` &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>  ,       (   ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;NULL).   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TList &#8212;    First, Last  Current  PNode (    <i></i>, <i></i>  <i></i>  ) &#8212;   InsertLast(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>   &nbsp;<i>L</i> (<i>L</i> &#8212;      TList, <i>D</i> &#8212;    ).    .             (   )      ,    .`
	d.ru[60] = ` &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>  ,       (   ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;NULL).   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TList (.  Dynamic59),   InsertFirst(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>   &nbsp;<i>L</i> (<i>L</i> &#8212;      TList, <i>D</i> &#8212;    ).    .             (        )      ,    .`
	d.ru[61] = `   , ,       &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>.    .   TList (.  Dynamic59),   InsertBefore(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>    &nbsp;<i>L</i> (<i>L</i> &#8212;      TList, <i>D</i> &#8212;    ).    .                 ,    .`
	d.ru[62] = `   , ,       &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>.    .   TList (.  Dynamic59),   InsertAfter(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>    &nbsp;<i>L</i> (<i>L</i> &#8212;      TList, <i>D</i> &#8212;    ).    .                 ,    .`
	d.ru[63] = `   , ,       &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>.   TList (.  Dynamic59),   ToFirst(<i>L</i>) (    &nbsp;<i>L</i>), ToNext(<i>L</i>) (   &nbsp;<i>L</i>  ,   ), SetData(<i>L</i>,&nbsp;<i>D</i>) (   &nbsp;<i>L</i> &nbsp;<i>D</i>  )   IsLast(<i>L</i>)   ( true,    &nbsp;<i>L</i>    ,  false   ). &nbsp;<i>L</i>   TList;   ToFirst  ToNext     .                     ,      ,     (      ).`
	d.ru[64] = `   , ,       &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>.   TList (.  Dynamic59),   ToLast(<i>L</i>) (    &nbsp;<i>L</i>), ToPrev(<i>L</i>) (   &nbsp;<i>L</i>  ,   )   GetData(<i>L</i>)   (    &nbsp;<i>L</i>), IsFirst(<i>L</i>)   ( true,    &nbsp;<i>L</i>    ,  false   ). &nbsp;<i>L</i>   TList;   ToLast  ToPrev     .             ,    .      .`
	d.ru[65] = ` &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>  ,      ,     .   TList (.  Dynamic59),   DeleteCurrent(<i>L</i>)  ,    <i>L</i>       (<i>L</i> &#8212;      TList).        ,     ,   .    ,   .              .     ,      (     &nbsp;NULL).`
	d.ru[66] = ` &nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> &nbsp;<i>P</i><sub>3</sub>  ,       .   TList (.  Dynamic59),   SplitList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>),    &nbsp;<i>L</i><sub>1</sub>       &nbsp;<i>L</i><sub>2</sub> ( , &nbsp;<i>L</i><sub>1</sub>    ,      ).     TList;      ,  &#8212; .         .         .             ,      .`
	d.ru[67] = `   ,        .   TList (.  Dynamic59),   AddList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>),      &nbsp;<i>L</i><sub>1</sub> (   )   &nbsp;<i>L</i><sub>2</sub>;   &nbsp;<i>L</i><sub>1</sub>  .   &nbsp;<i>L</i><sub>2</sub>     .      TList     .         .                ,      .`
	d.ru[68] = `   ,        .   TList (.  Dynamic59),   InsertList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>),      &nbsp;<i>L</i><sub>1</sub> (   )  &nbsp;<i>L</i><sub>2</sub>    ;   &nbsp;<i>L</i><sub>1</sub>  .   &nbsp;<i>L</i><sub>2</sub>     .      TList     .         .                 ,      .`
	d.ru[69] = `   ,        (    ).   TList (.  Dynamic59),   MoveCurrent(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>),     &nbsp;<i>L</i><sub>1</sub>  &nbsp;<i>L</i><sub>2</sub> (     &nbsp;<i>L</i><sub>2</sub>    ;  &nbsp;<i>L</i><sub>1</sub>     ,     ,  ).      TList     .         .               ,      .`
	d.ru[70] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       ,     ,      (  ,  <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL).     <i> </i> (.  Dynamic55),  <i> </i>.     &nbsp;0      Next  Prev        (      Next  Prev        ).       .         .`
	d.ru[71] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        (     .  Dynamic70).    ,                 .        ,       (.&nbsp;.     ).       .           .`
	d.ru[72] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       (     .  Dynamic70).   ,        (         ).          (    ,        ).         .`
	d.ru[73] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       (     .  Dynamic70).   ,        (         ).          (    ,        ).         .`
	d.ru[74] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        (     .  Dynamic70).   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TListB &#8212;    Barrier  Current  PNode (    <i></i>  <i></i>  ) &#8212;   LBInsertLast(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>   &nbsp;<i>L</i> (<i>L</i> &#8212;      TListB, <i>D</i> &#8212;    ).    .             (   )       .`
	d.ru[75] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       .   &nbsp;<i>N</i> (&gt;&nbsp;0)    <i>N</i>&nbsp;.   TListB (.  Dynamic74),   LBInsertFirst(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>   &nbsp;<i>L</i> (<i>L</i> &#8212;      TListB, <i>D</i> &#8212;    ).    .             (        )       .`
	d.ru[76] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       .    .   TListB (.  Dynamic74),   LBInsertBefore(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>    &nbsp;<i>L</i> (<i>L</i> &#8212;      TListB, <i>D</i> &#8212;    ).    .                  .`
	d.ru[77] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       .    .   TListB (.  Dynamic74),   LBInsertAfter(<i>L</i>,&nbsp;<i>D</i>),      &nbsp;<i>D</i>    &nbsp;<i>L</i> (<i>L</i> &#8212;      TListB, <i>D</i> &#8212;    ).    .                  .`
	d.ru[78] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       .   TListB (.  Dynamic74),   LBToFirst(<i>L</i>) (    &nbsp;<i>L</i>), LBToNext(<i>L</i>) (   &nbsp;<i>L</i>  ), LBSetData(<i>L</i>,&nbsp;<i>D</i>) (   &nbsp;<i>L</i> &nbsp;<i>D</i>  ,      )   IsBarrier(<i>L</i>)   ( true,    &nbsp;<i>L</i>    ,  false   ). &nbsp;<i>L</i>   TListB;   LBToFirst  LBToNext     .                     ,        (       ).      ;          .`
	d.ru[79] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>       .   TListB (.  Dynamic74),   LBToLast(<i>L</i>) (    &nbsp;<i>L</i>), LBToPrev(<i>L</i>) (   &nbsp;<i>L</i>  )   LBGetData(<i>L</i>)   (    &nbsp;<i>L</i>). &nbsp;<i>L</i>   TListB;   LBToLast  LBToPrev     .      ,    IsBarrier   Dynamic78,       ,    .      .          .`
	d.ru[80] = ` &nbsp;<i>P</i><sub>1</sub> &nbsp;<i>P</i><sub>2</sub>        ,       .   TListB (.  Dynamic74),   LBDeleteCurrent(<i>L</i>)  ,   &nbsp;<i>L</i>       (<i>L</i> &#8212;      TListB).     ,     ,   .    ,   .      ,        &nbsp;0.    ,    IsBarrier   Dynamic78,       (  ,    )    .       .`
}
