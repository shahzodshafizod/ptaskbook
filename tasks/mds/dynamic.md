## Dynamic 1
#### ![en](https://img.shields.io/badge/EN-blue) An address&nbsp;<i>P</i><sub>1</sub> of a record of TNode type is given. The record consists of the <i>Data</i> field (of integer type) and the <i>Next</i> field (of PNode type that refers to a variable of TNode type). The given record is linked by its <i>Next</i> field with the next record of the same type. Output the value of the <i>Data</i> field for each record and the address&nbsp;<i>P</i><sub>2</sub> of the record that follows the given one.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан адрес&nbsp;<i>P</i><sub>1</sub> записи типа TNode, содержащей поле Data (целого типа) и поле Next (типа PNode &#8212; указателя на TNode). Эта запись связана полем Next со следующей записью того же типа. Вывести значения полей Data обеих записей, а также адрес&nbsp;<i>P</i><sub>2</sub> следующей записи.

---

## Dynamic 2
#### ![en](https://img.shields.io/badge/EN-blue) An address&nbsp;<i>P</i><sub>1</sub> of a record of TNode type is given. The record is linked by its <i>Next</i> field with the next record of the same type, that record is linked with the next one, and so on, until the last record whose <i>Next</i> field equals NULL (as a result, we obtain a <i>chain</i> of linked records). Output the value of the <i>Data</i> field for each chain component, the chain <i>length</i> (that is, the amount of its components) and the address of the last chain component.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан адрес&nbsp;<i>P</i><sub>1</sub> записи типа TNode. Эта запись связана полем Next со следующей записью того же типа, она, в свою очередь, &#8212; со следующей, и так далее до записи, поле Next которой равно NULL (таким образом, возникает <i>цепочка</i> связанных записей). Вывести значения полей Data для всех элементов цепочки, <i>длину цепочки</i> (т.&nbsp;е. число ее элементов) и адрес ее последнего элемента.

---

## Dynamic 3
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack are given. Push a component with the value&nbsp;<i>D</i> onto the stack and output the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>D</i> и указатель&nbsp;<i>P</i><sub>1</sub> на вершину непустого стека. Добавить элемент со значением&nbsp;<i>D</i> в стек и вывести адрес&nbsp;<i>P</i><sub>2</sub> новой вершины стека.

---

## Dynamic 4
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Create a stack that contains <i>N</i>&nbsp;components with the given values (a component with the last value must be the top of the stack) and output a pointer to the top of the stack.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать стек, содержащий исходные числа (последнее число будет вершиной стека), и вывести указатель на его вершину.

---

## Dynamic 5
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack is given. Pop the top component off the stack and output its value&nbsp;<i>D</i> and the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack. If the stack will be empty after popping the component then&nbsp;<i>P</i><sub>2</sub> must be equal to NULL. After popping the component release the memory allocated for this component.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину непустого стека. Извлечь из стека первый (верхний) элемент и вывести его значение&nbsp;<i>D</i>, а также адрес&nbsp;<i>P</i><sub>2</sub> новой вершины стека. Если после извлечения элемента стек окажется пустым, то положить <i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL. После извлечения элемента из стека освободить память, занимаемую этим элементом.

---

## Dynamic 6
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given; the stack contains at least ten components. Pop the first nine components off the stack and output their values and the address&nbsp;<i>P</i><sub>2</sub> of a new top of the stack. After popping components release the memory allocated for these components.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину стека, содержащего не менее десяти элементов. Извлечь из стека первые девять элементов и вывести их значения. Вывести также адрес новой вершины стека. После извлечения элементов из стека освобождать память, которую они занимали.

---

## Dynamic 7
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given (if the stack is empty then&nbsp;<i>P</i><sub>1</sub> equals NULL). Pop all components off the stack and output their values. Also output the amount of popped components (if the stack is empty then output&nbsp;0). After popping components release the memory allocated for these components.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину стека (если стек пуст, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;NULL). Извлечь из стека все элементы и вывести их значения. Вывести также количество извлеченных элементов&nbsp;<i>N</i> (для пустого стека вывести&nbsp;0). После извлечения элементов из стека освобождать память, которую они занимали.

---

## Dynamic 8
#### ![en](https://img.shields.io/badge/EN-blue) Two pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> that refer to the tops of two nonempty stacks are given. Move all components from the first stack into the second one (as a result, all components of the first stack will be contained within the second stack in inverse order). Output the address of a new top of the second stack. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на вершины двух непустых стеков. Переместить все элементы из первого стека во второй (в результате элементы первого стека будут располагаться во втором стеке в порядке, обратном исходному) и вывести адрес новой вершины второго стека. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 9
#### ![en](https://img.shields.io/badge/EN-blue) Two pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> that refer to the tops of two nonempty stacks are given. Move components from the first stack into the second one until the value of the top component of the first stack is equal to an even number (as a result, all components having been moved will be contained within the second stack in inverse order). If the first stack contains no components with even values then move all its components. Output the address of a new top for each stack (if the first stack will be empty then output NULL for this stack). Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на вершины двух непустых стеков. Перемещать элементы из первого стека во второй, пока значение вершины первого стека не станет четным (перемещенные элементы первого стека будут располагаться во втором стеке в порядке, обратном исходному). Если в первом стеке нет элементов с четными значениями, то переместить из первого стека во второй все элементы. Вывести адреса новых вершин первого и второго стека (если первый стек окажется пустым, то вывести для него константу NULL). Операции выделения и освобождения памяти не использовать.

---

## Dynamic 10
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a nonempty stack is given. Create two new stacks by moving the given stack components whose values are even (odd) numbers into the first (second) new stack respectively. As a result, all components having been moved will be contained within each new stack in inverse order; one of the new stacks may be empty. Output the address of the top for each new stack (if one of the new stacks will be empty then output NULL for this stack). Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину непустого стека. Создать два новых стека, переместив в первый из них все элементы исходного стека с четными значениями, а во второй &#8212; с нечетными (элементы в новых стеках будут располагаться в порядке, обратном исходному; один из этих стеков может оказаться пустым). Вывести адреса вершин полученных стеков (для пустого стека вывести&nbsp;NULL). Операции выделения и освобождения памяти не использовать.

---

## Dynamic 11
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given (if the stack is empty then&nbsp;<i>P</i><sub>1</sub> equals NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TStack that is a record with one field, <i>Top</i>, of PNode type (the field refers to the top of a stack). Also write a procedure Push(<i>S</i>,&nbsp;<i>D</i>) that pushes a new component with the value&nbsp;<i>D</i> onto a stack&nbsp;<i>S</i> (a record&nbsp;<i>S</i> of TStack type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). Using this procedure, push all elements of the given sequence onto the given stack (the last number must be the value of the top component). Output the address of a new top of the stack.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину стека (если стек пуст, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;NULL). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Описать тип TStack &#8212; запись с одним полем Top типа PNode (поле указывает на <i>вершину</i> стека) &#8212; и процедуру Push(<i>S</i>,&nbsp;<i>D</i>), которая добавляет в стек&nbsp;<i>S</i> новый элемент со значением&nbsp;<i>D</i> (<i>S</i> &#8212; входной и выходной параметр типа TStack, <i>D</i> &#8212; входной параметр целого типа). С помощью процедуры Push добавить в исходный стек данный набор чисел (последнее число будет вершиной стека) и вывести адрес новой вершины стека.

---

## Dynamic 12
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given; the stack contains at least five components. Using the TStack type (see Dynamic11), write an integer function Pop(<i>S</i>) that pops the top component off a stack&nbsp;<i>S</i>, releases memory allocated for this component and returns its value (a record&nbsp;<i>S</i> of TStack type is an input and output parameter). Using this function, pop five components off the given stack and output their values. Also output a pointer that refers to a new top of the stack (if the stack will be empty then this pointer must be equal to NULL).
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину стека, содержащего не менее пяти элементов. Используя тип TStack (см. задание Dynamic11), описать функцию Pop(<i>S</i>) целого типа, которая извлекает из стека&nbsp;<i>S</i> первый (верхний) элемент, возвращает его значение и освобождает память, которую занимал извлеченный элемент (<i>S</i> &#8212; входной и выходной параметр типа TStack). С помощью функции Pop извлечь из исходного стека пять элементов и вывести их значения. Вывести также указатель на новую вершину стека (если результирующий стек окажется пустым, то этот указатель должен быть равен&nbsp;NULL).

---

## Dynamic 13
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the top of a stack is given. Using the TStack type (see Dynamic11), write two functions: a logical function StackIsEmpty(<i>S</i>) that returns true if a stack&nbsp;<i>S</i> is empty, and false otherwise, and an integer function Peek(<i>S</i>) that returns the value of the top component of the stack&nbsp;<i>S</i>. A record&nbsp;<i>S</i> of TStack type is an input parameter for each function. Using these functions and the Pop function from the task Dynamic12, pop five components (or all stack components if their amount is less than five) off the given stack and output their values. Also output the return value of the StackIsEmpty function for the resulting stack. At last, in the case of the nonempty resulting stack, output the value and the address of its top component.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на вершину стека. Используя тип TStack (см. задание Dynamic11), описать функции StackIsEmpty(<i>S</i>) логического типа (возвращает true, если стек&nbsp;<i>S</i> пуст, и false в противном случае) и Peek(<i>S</i>) целого типа (возвращает значение вершины непустого стека&nbsp;<i>S</i>, не удаляя ее из стека). В обеих функциях переменная&nbsp;<i>S</i> является входным параметром типа TStack. С помощью этих функций, а также функции Pop из задания Dynamic12, извлечь из исходного стека пять элементов (или все содержащиеся в нем элементы, если их менее пяти) и вывести их значения. Вывести также значение функции StackIsEmpty для результирующего стека и, если результирующий стек не является пустым, значение и адрес его новой вершины.

---

## Dynamic 14
#### ![en](https://img.shields.io/badge/EN-blue) A sequence of 10&nbsp;integers is given. Create a queue that contains components with the given values (a component with the first value must be the head of the queue, a component with the last value must be the tail of the queue) and output pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of the queue respectively.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан набор из 10&nbsp;чисел. Создать очередь, содержащую данные числа в указанном порядке (первое число будет размещаться в начале очереди, последнее &#8212; в конце), и вывести указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди.

---

## Dynamic 15
#### ![en](https://img.shields.io/badge/EN-blue) A sequence of 10&nbsp;integers is given. Create two queues; the first one must contain the given integers with odd order numbers (1, 3,&nbsp;&#8230;, 9), the second one must contain the given integers with even order numbers (2, 4,&nbsp;&#8230;, 10). Output pointers to the head and tail of the first queue and then output pointers to the head and tail of the second one.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан набор из 10&nbsp;чисел. Создать две очереди: первая должна содержать числа из исходного набора с нечетными номерами (1, 3,&nbsp;&#8230;, 9), а вторая &#8212; с четными (2, 4,&nbsp;&#8230;, 10); порядок чисел в каждой очереди должен совпадать с порядком чисел в исходном наборе. Вывести указатели на начало и конец первой, а затем второй очереди.

---

## Dynamic 16
#### ![en](https://img.shields.io/badge/EN-blue) A sequence of 10&nbsp;integers is given. Create two queues; the first one must contain the given integers with odd values (in the same order), the second one must contain the given integers with even values (in the same order). Output pointers to the head and tail of the first queue and then output pointers to the head and tail of the second one (if one of the queues will be empty then output NULL twice for this queue).
#### ![ru](https://img.shields.io/badge/RU-blue) Дан набор из 10&nbsp;чисел. Создать две очереди: первая должна содержать все нечетные, а вторая &#8212; все четные числа из исходного набора (порядок чисел в каждой очереди должен совпадать с порядком чисел в исходном наборе). Вывести указатели на начало и конец первой, а затем второй очереди (одна из очередей может оказаться пустой; в этом случае вывести для нее две константы&nbsp;NULL).

---

## Dynamic 17
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>D</i> and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given (if the queue is empty then the pointers equal NULL). Add a component with the value&nbsp;<i>D</i> to the end of the queue and output the new addresses of the head and tail of the queue.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>D</i> и указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди (если очередь является пустой, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL). Добавить элемент со значением&nbsp;<i>D</i> в конец очереди и вывести новые адреса начала и конца очереди.

---

## Dynamic 18
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>D</i> and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given; the queue contains at least two components. Add a component with the value&nbsp;<i>D</i> to the end of the queue and remove the first component from the front of the queue. Output the value of the component being removed and also output the new addresses of the head and tail of the queue. After removing the component release the memory allocated for this component.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>D</i> и указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди, содержащей не менее двух элементов. Добавить элемент со значением&nbsp;<i>D</i> в конец очереди и извлечь из очереди первый (начальный) элемент. Вывести значение извлеченного элемента и новые адреса начала и конца очереди. После извлечения элемента из очереди освободить память, занимаемую этим элементом.

---

## Dynamic 19
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a nonempty queue are given. Remove <i>N</i>&nbsp;initial components from the queue and output their values (if the queue contains less than <i>N</i>&nbsp;components then remove all its components). Also output the new addresses of the head and tail of the queue (if the resulting queue will be empty then output NULL twice). After removing components release the memory allocated for them.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец непустой очереди. Извлечь из очереди <i>N</i>&nbsp;начальных элементов и вывести их значения (если очередь содержит менее <i>N</i>&nbsp;элементов, то извлечь все ее элементы). Вывести также новые адреса начала и конца очереди (для пустой очереди дважды вывести NULL). После извлечения элементов из очереди освобождать память, которую они занимали.

---

## Dynamic 20
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a nonempty queue are given. Remove components from the front of the queue until the value of the head of the queue is equal to an even number; output values of all components being removed (if the queue contains no components with even values then remove all its components). Also output the new addresses of the head and tail of the queue (if the resulting queue will be empty then output NULL twice). After removing components release the memory allocated for them.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец непустой очереди. Извлекать из очереди элементы, пока значение начального элемента очереди не станет четным, и выводить значения извлеченных элементов (если очередь не содержит элементов с четными значениями, то извлечь все ее элементы). Вывести также новые адреса начала и конца очереди (для пустой очереди дважды вывести NULL). После извлечения элементов из очереди освобождать память, которую они занимали.

---

## Dynamic 21
#### ![en](https://img.shields.io/badge/EN-blue) Two queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one (if some queue is empty then the corresponding pointers equal NULL). Move all components from the first queue (starting with its first component) to the end of the second one. Output the new addresses of the head and tail of the second queue. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны две очереди; адреса начала и конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а второй &#8212; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub> (если очередь является пустой, то соответствующие адреса равны&nbsp;NULL). Переместить все элементы первой очереди (в порядке от начала к концу) в конец второй очереди и вывести новые адреса начала и конца второй очереди. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 22
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>N</i> (&gt;&nbsp;0) and two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. Move <i>N</i>&nbsp;initial components of the first queue to the end of the second one (if the first queue contains less than <i>N</i>&nbsp;components then move all its components). Output the new addresses of the head and tail of the first queue and then output the new addresses of the head and tail of the second one (if the first queue will be empty then output NULL twice for this queue). Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и две непустые очереди; адреса начала и конца первой равны <i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а второй &#8212; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Переместить <i>N</i>&nbsp;начальных элементов первой очереди в конец второй очереди. Если первая очередь содержит менее <i>N</i>&nbsp;элементов, то переместить из первой очереди во вторую все элементы. Вывести новые адреса начала и конца первой, а затем второй очереди (для пустой очереди дважды вывести&nbsp;NULL). Операции выделения и освобождения памяти не использовать.

---

## Dynamic 23
#### ![en](https://img.shields.io/badge/EN-blue) Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. Move initial components of the first queue to the end of the second one until the value of the head of the first queue is equal to an even number (if the first queue contains no components with even values then move all its components). Output the new addresses of the head and tail of the first queue and then output the new addresses of the head and tail of the second one (if the first queue will be empty then output NULL twice for this queue). Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны две непустые очереди; адреса начала и конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а второй &#8212; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Перемещать элементы из начала первой очереди в конец второй, пока значение начального элемента первой очереди не станет четным (если первая очередь не содержит четных элементов, то переместить из первой очереди во вторую все элементы). Вывести новые адреса начала и конца первой, а затем второй очереди (для пустой очереди дважды вывести&nbsp;NULL). Операции выделения и освобождения памяти не использовать.

---

## Dynamic 24
#### ![en](https://img.shields.io/badge/EN-blue) Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. The queues contain the equal amount of components. Combine the given queues into a new one; the resulting queue must contain alternating components of the given queues starting with the head of the first one. Output pointers to the head and tail of the resulting queue. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны две непустые очереди; адреса начала и конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а второй &#8212; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Очереди содержат одинаковое количество элементов. Объединить очереди в одну, в которой элементы исходных очередей чередуются (начиная с первого элемента первой очереди). Вывести указатели на начало и конец полученной очереди. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 25
#### ![en](https://img.shields.io/badge/EN-blue) Two nonempty queues are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the head and tail of the first one, pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> refer to the head and tail of the second one. The values of components of each given queue are in ascending order. Combine the given queues into a new one; the values of components of the resulting queue must be in ascending order too. Output pointers to the head and tail of the resulting queue. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны две непустые очереди; адреса начала и конца первой равны&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub>, а второй &#8212; <i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub>. Элементы каждой из очередей упорядочены по возрастанию (в направлении от начала очереди к концу). Объединить очереди в одну с сохранением упорядоченности элементов. Вывести указатели на начало и конец полученной очереди. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 26
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given (if the queue is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TQueue that is a record with two fields, <i>Head</i> and <i>Tail</i>, of PNode type (the fields refer to the head and tail of a queue respectively). Also write a procedure Enqueue(<i>Q</i>,&nbsp;<i>D</i>) that adds a new component with the value&nbsp;<i>D</i> to the end of a queue&nbsp;<i>Q</i> (a record&nbsp;<i>Q</i> of TQueue type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). Using this procedure, add all elements of the given sequence to the end of the given queue. Output the new addresses of the head and tail of the queue.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди (если очередь является пустой, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Описать тип TQueue &#8212; запись с двумя полями Head и Tail типа PNode (поля указывают на <i>начало</i> и <i>конец</i> очереди) &#8212; и процедуру Enqueue(<i>Q</i>,&nbsp;<i>D</i>), которая добавляет в конец очереди&nbsp;<i>Q</i> новый элемент со значением&nbsp;<i>D</i> (<i>Q</i> &#8212; входной и выходной параметр типа TQueue, <i>D</i> &#8212; входной параметр целого типа). С помощью процедуры Enqueue добавить в исходную очередь данный набор чисел и вывести новые адреса ее начала и конца.

---

## Dynamic 27
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given; the queue contains at least five components. Using the TQueue type (see Dynamic26), write an integer function Dequeue(<i>Q</i>) that removes the first component from the front of a queue&nbsp;<i>Q</i>, releases memory allocated for this component and returns its value (a record&nbsp;<i>Q</i> of TQueue type is an input and output parameter). Using this function, remove five initial components from the front of the given queue and output their values. Also output the new addresses of the head and tail of the queue (if the queue will be empty then output NULL twice).
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди, содержащей не менее пяти элементов. Используя тип TQueue (см. задание Dynamic26), описать функцию Dequeue(<i>Q</i>) целого типа, которая извлекает из очереди первый (начальный) элемент, возвращает его значение и освобождает память, занимаемую извлеченным элементом (<i>Q</i> &#8212; входной и выходной параметр типа TQueue). С помощью функции Dequeue извлечь из исходной очереди пять начальных элементов и вывести их значения. Вывести также адреса начала и конца результирующей очереди (если очередь окажется пустой, то эти адреса должны быть равны&nbsp;NULL).

---

## Dynamic 28
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the head and tail of a queue are given. Using the TQueue type (see Dynamic26), write a logical function QueueIsEmpty(<i>Q</i>) that returns true if a queue&nbsp;<i>Q</i> is empty, and false otherwise (a record&nbsp;<i>Q</i> of TQueue type is an input parameter). Using this function and also the Dequeue function from the task Dynamic27, remove five initial components (or all queue components if their amount is less than five) from the front of the given queue and output their values. Also output the return value of the QueueIsEmpty function for the resulting queue and the new addresses of the head and tail of this queue (if the queue will be empty then output NULL twice).
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на начало и конец очереди. Используя тип TQueue (см. задание Dynamic26), описать функцию QueueIsEmpty(<i>Q</i>) логического типа, которая возвращает true, если очередь&nbsp;<i>Q</i> пуста, и false в противном случае (<i>Q</i> &#8212; входной параметр типа TQueue). Используя эту функцию для проверки состояния очереди, а также функцию Dequeue из задания Dynamic27, извлечь из исходной очереди пять начальных элементов (или все содержащиеся в ней элементы, если их менее пяти) и вывести их значения. Вывести также значение функции QueueIsEmpty для полученной очереди и новые адреса ее начала и конца.

---

## Dynamic 29
#### ![en](https://img.shields.io/badge/EN-blue) An address&nbsp;<i>P</i><sub>2</sub> of a record of TNode type is given. The record consists of the following fields: <i>Data</i> (of integer type), <i>Prev</i>, <i>Next</i> (each of PNode type that refers to a variable of TNode type). The given record is linked by its <i>Prev</i> and <i>Next</i> field with the previous and next record of the same type respectively. Output the values of the <i>Data</i> field for the previous and next record, and also output the addresses&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>3</sub> of these records.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан адрес <i>P</i><sub>2</sub> записи типа TNode, содержащей поле Data (целого типа) и поля Prev и Next (типа PNode &#8212; указателя на TNode). Эта запись связана полями Prev и Next соответственно с предыдущей и последующей записью того же типа. Вывести значения полей Data предыдущей и последующей записи, а также адреса&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>3</sub> предыдущей и последующей записи.

---

## Dynamic 30
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the beginning of a chain of records is given; the records have TNode type and are linked by their <i>Next</i> fields. Using the <i>Prev</i> field of the TNode record, transform the given (<i>singly linked</i>) chain into the <i>doubly linked</i> chain whose components are linked not only with the next ones (by the <i>Next</i> field) but also with the previous ones (by the <i>Prev</i> field). The <i>Prev</i> field of the first chain component must be equal to NULL. Output the address of the last component of the resulting chain.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель <i>P</i><sub>1</sub> на начало непустой цепочки элементов-записей типа TNode, связанных между собой с помощью поля Next. Используя поле Prev записи TNode, преобразовать исходную (<i>односвязную</i>) цепочку в <i>двусвязную</i>, в которой каждый элемент связан не только с последующим элементом (с помощью поля Next), но и с предыдущим (с помощью поля Prev). Поле Prev первого элемента положить равным&nbsp;NULL. Вывести указатель на последний элемент преобразованной цепочки.

---

## Dynamic 31
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Output the amount&nbsp;<i>N</i> of the list components and also pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component respectively.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Вывести число&nbsp;<i>N</i> &#8212; количество элементов в списке, а также указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы списка.

---

## Dynamic 32
#### ![en](https://img.shields.io/badge/EN-blue) Two integers&nbsp;<i>D</i><sub>1</sub>, <i>D</i><sub>2</sub> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i><sub>1</sub> at the beginning of the list; insert a new component with the value&nbsp;<i>D</i><sub>2</sub> at the end of the list. Output the addresses of the first and last list component.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны числа&nbsp;<i>D</i><sub>1</sub> и&nbsp;<i>D</i><sub>2</sub> и указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Добавить в начало списка новый элемент со значением&nbsp;<i>D</i><sub>1</sub>, а в конец &#8212; новый элемент со значением&nbsp;<i>D</i><sub>2</sub>. Вывести адреса первого и последнего элементов полученного списка.

---

## Dynamic 33
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i> before the given list component. Output the address of the component being inserted.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>D</i> и указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Вставить перед данным элементом списка новый элемент со значением&nbsp;<i>D</i> и вывести указатель на добавленный элемент списка.

---

## Dynamic 34
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>D</i> and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Insert a new component with the value&nbsp;<i>D</i> after the given list component. Output the address of the component being inserted.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>D</i> и указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Вставить после данного элемента списка новый элемент со значением&nbsp;<i>D</i> и вывести указатель на добавленный элемент списка.

---

## Dynamic 35
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The list contains at least two components. Double occurrences of the first and last list component (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы двусвязного списка, содержащего не менее двух элементов. Продублировать в списке первый и последний элементы (новые элементы добавлять перед существующими элементами с такими же значениями) и вывести указатель на первый элемент преобразованного списка.

---

## Dynamic 36
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The list contains at least two components. Double occurrences of the first and last list component (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы двусвязного списка, содержащего не менее двух элементов. Продублировать в списке первый и последний элементы (новые элементы добавлять после существующих элементов с такими же значениями) и вывести указатель на последний элемент преобразованного списка.

---

## Dynamic 37
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd order numbers (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Продублировать в списке все элементы с нечетными номерами (новые элементы добавлять перед существующими элементами с такими же значениями) и вывести указатель на первый элемент преобразованного списка.

---

## Dynamic 38
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd order numbers (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Продублировать в списке все элементы с нечетными номерами (новые элементы добавлять после существующих элементов с такими же значениями) и вывести указатель на последний элемент преобразованного списка.

---

## Dynamic 39
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd values (new components must be inserted before the existing ones with the same value). Output the address of the first component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Продублировать в списке все элементы с нечетными значениями (новые элементы добавлять перед существующими элементами с такими же значениями) и вывести указатель на первый элемент преобразованного списка.

---

## Dynamic 40
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Double occurrences of all list components with odd values (new components must be inserted after the existing ones with the same value). Output the address of the last component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Продублировать в списке все элементы с нечетными значениями (новые элементы добавлять после существующих элементов с такими же значениями) и вывести указатель на последний элемент преобразованного списка.

---

## Dynamic 41
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Remove this component from the list and output the addresses of its previous and next component in the list (one or both these components may be absent; output NULL for each absent component). After removing the component release the memory allocated for this component.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Удалить из списка данный элемент и вывести два указателя: на элемент, предшествующий удаленному, и на элемент, следующий за удаленным (один или оба этих элемента могут отсутствовать; для отсутствующих элементов выводить&nbsp;NULL). После удаления элемента из списка освободить память, занимаемую этим элементом.

---

## Dynamic 42
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a doubly linked list is given. The list contains at least two components. Remove all components with odd order numbers from the list and output the address of the first component of the resulting list. After removing components release the memory allocated for them.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент двусвязного списка, содержащего не менее двух элементов. Удалить из списка все элементы с нечетными номерами и вывести указатель на первый элемент преобразованного списка. После удаления элементов из списка освобождать память, которую они занимали.

---

## Dynamic 43
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Remove all components with odd values from the list and output the address of the first component of the resulting list (if this list will be empty then output NULL). After removing components release the memory allocated for them.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Удалить из списка все элементы с нечетными значениями и вывести указатель на первый элемент преобразованного списка (если в результате удаления элементов список окажется пустым, то вывести&nbsp;NULL). После удаления элементов из списка освобождать память, которую они занимали.

---

## Dynamic 44
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Move this component to the end of the list and output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Переместить данный элемент в конец списка и вывести указатели на первый и последний элементы преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 45
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list is given. Move this component to the beginning of the list and output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Переместить данный элемент в начало списка и вывести указатели на первый и последний элементы преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 46
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Move this component by <i>K</i>&nbsp;positions forward in the list (if the list contains less than <i>K</i>&nbsp;components after the given component then move it to the end of the list). Output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Переместить в списке данный элемент на <i>K</i>&nbsp;позиций вперед (если после данного элемента находится менее <i>K</i>&nbsp;элементов, то переместить его в конец списка). Вывести указатели на первый и последний элементы преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 47
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and a pointer&nbsp;<i>P</i><sub>0</sub> to one of the components of a nonempty doubly linked list are given. Move this component by <i>K</i>&nbsp;positions backward in the list (if the list contains less than <i>K</i>&nbsp;components before the given component then move it to the beginning of the list). Output the addresses of the first and last component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и указатель&nbsp;<i>P</i><sub>0</sub> на один из элементов непустого двусвязного списка. Переместить в списке данный элемент на <i>K</i>&nbsp;позиций назад (если перед данным элементом находится менее <i>K</i>&nbsp;элементов, то переместить его в начало списка). Вывести указатели на первый и последний элементы преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 48
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Exchange the given components in the list and output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на два различных элемента двусвязного списка (элемент с адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в списке перед элементом с адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но не обязательно рядом с ним). Поменять местами данные элементы и вывести указатель на первый элемент преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 49
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Rearrange list components by moving all components with odd order numbers to the end of the list (in the same order). Output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Перегруппировать его элементы, переместив все элементы с нечетными номерами в конец списка (в том же порядке) и вывести указатель на первый элемент преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 50
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Rearrange list components by moving all components with odd values to the end of the list (in the same order). Output the address of the first component of the resulting list. Do not use operations of allocating and freeing memory; do not change the <i>Data</i> fields.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Перегруппировать его элементы, переместив все элементы с нечетными значениями в конец списка (в том же порядке) и вывести указатель на первый элемент преобразованного списка. Операции выделения и освобождения памяти не использовать, поля Data не изменять.

---

## Dynamic 51
#### ![en](https://img.shields.io/badge/EN-blue) Two nonempty doubly linked lists are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the first and last component of the first list, a pointer&nbsp;<i>P</i><sub>0</sub> refers to one of the components of the second list. Combine the given lists by inserting all components of the first list (in the same order) before the given component of the second list. Output the addresses of the first and last component of the combined list. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны два непустых двусвязных списка и связанные с ними указатели:&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> указывают на первый и последний элементы первого списка, <i>P</i><sub>0</sub> &#8212; на один из элементов второго. Объединить исходные списки, поместив все элементы первого списка (в том же порядке) перед данным элементом второго списка, и вывести указатели на первый и последний элементы объединенного списка. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 52
#### ![en](https://img.shields.io/badge/EN-blue) Two nonempty doubly linked lists are given; pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> refer to the first and last component of the first list, a pointer&nbsp;<i>P</i><sub>0</sub> refers to one of the components of the second list. Combine the given lists by inserting all components of the first list (in the same order) after the given component of the second list. Output the addresses of the first and last component of the combined list. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны два непустых двусвязных списка и связанные с ними указатели:&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> указывают на первый и последний элементы первого списка, <i>P</i><sub>0</sub> &#8212; на один из элементов второго. Объединить исходные списки, поместив все элементы первого списка (в том же порядке) после данного элемента второго списка, и вывести указатели на первый и последний элементы объединенного списка. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 53
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Move list components that are located between the given components (including these components) to a new list (in the same order). Output the addresses of the first components of the changed and new list. If the changed list will be empty then output NULL for this list. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на два различных элемента двусвязного списка; элемент с адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в списке перед элементом с адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но не обязательно рядом с ним. Переместить элементы, расположенные между данными элементами (включая данные элементы), в новый список (в том же порядке). Вывести указатели на первые элементы преобразованного и нового списков. Если преобразованный список окажется пустым, то связанный с ним указатель положить равным&nbsp;NULL. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 54
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub><i>X</i></sub> and&nbsp;<i>P</i><sub><i>Y</i></sub> to different components of a doubly linked list are given. The component with the address&nbsp;<i>P</i><sub><i>X</i></sub> precedes the component with the address&nbsp;<i>P</i><sub><i>Y</i></sub> in the list but need not be adjacent with it. Move list components that are located between the given components (not including these components) to a new list (in the same order). Output the addresses of the first components of the changed and new list. If the new list will be empty then output NULL for this list. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub><i>X</i></sub> и&nbsp;<i>P</i><sub><i>Y</i></sub> на два различных элемента двусвязного списка; элемент с адресом&nbsp;<i>P</i><sub><i>X</i></sub> находится в списке перед элементом с адресом&nbsp;<i>P</i><sub><i>Y</i></sub>, но не обязательно рядом с ним. Переместить элементы, расположенные между данными элементами (не включая данные элементы), в новый список (в том же порядке). Вывести указатели на первые элементы преобразованного и нового списков. Если новый список окажется пустым, то связанный с ним указатель положить равным&nbsp;NULL. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 55
#### ![en](https://img.shields.io/badge/EN-blue) A pointer&nbsp;<i>P</i><sub>1</sub> to the first component of a nonempty doubly linked list is given. Transform this list to the <i>circular</i> one by assigning the address of the first component to the <i>Next</i> field of the last component and the address of the last component to the <i>Prev</i> field of the first component. Output the address of the component that has been the last component of the given list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан указатель&nbsp;<i>P</i><sub>1</sub> на первый элемент непустого двусвязного списка. Преобразовать список в <i>циклический</i>, записав в поле Next последнего элемента списка адрес его первого элемента, а в поле Prev первого элемента &#8212; адрес последнего элемента. Вывести указатель на элемент, который был последним элементом исходного списка.

---

## Dynamic 56
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given. The amount of list components is an even number. Split the list into two <i>circular</i> lists (see Dynamic55); the first (second) resulting list must contain the first (second) half of components of the given list respectively. Output the pointers&nbsp;<i>P</i><sub>3</sub> and&nbsp;<i>P</i><sub>4</sub> to two middle components of the given list; the component with the address&nbsp;<i>P</i><sub>3</sub> must be contained in the first resulting circular list, the component with the address&nbsp;<i>P</i><sub>4</sub> must be contained in the second one. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы непустого двусвязного списка, содержащего четное количество элементов. Преобразовать список в два <i>циклических</i> списка (см. задание Dynamic55), первый из которых содержит первую половину элементов исходного списка, а второй &#8212; вторую половину. Вывести указатели&nbsp;<i>P</i><sub>3</sub> и&nbsp;<i>P</i><sub>4</sub> на два средних элемента исходного списка (элемент с адресом&nbsp;<i>P</i><sub>3</sub> должен входить в первый циклический список, а элемент с адресом&nbsp;<i>P</i><sub>4</sub> &#8212; во второй). Операции выделения и освобождения памяти не использовать.

---

## Dynamic 57
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a nonempty doubly linked list are given. Perform a <i>cyclic shift</i> of all list components by <i>K</i>&nbsp;positions forward (that is, from the beginning toward the end of the list). Output the addresses of the first and last component of the resulting list. The required shift should be performed as follows: transform the given list to the circular one (see Dynamic55) and then break this circular list at the position that corresponds to the given value of&nbsp;<i>K</i>. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы непустого двусвязного списка. Осуществить <i>циклический сдвиг</i> элементов списка на <i>K</i>&nbsp;позиций вперед (т.&nbsp;е. в направлении от начала к концу списка) и вывести указатели на первый и последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в циклический (см. задание Dynamic55), после чего &#171;разорвать&#187; его в позиции, соответствующей данному значению&nbsp;<i>K</i>. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 58
#### ![en](https://img.shields.io/badge/EN-blue) An integer&nbsp;<i>K</i> (&gt;&nbsp;0) and pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a nonempty doubly linked list are given. Perform a <i>cyclic shift</i> of all list components by <i>K</i>&nbsp;positions backward (that is, from the end toward the beginning of the list). Output the addresses of the first and last component of the resulting list. The required shift should be performed as follows: transform the given list to the circular one (see Dynamic55) and then break this circular list at the position that corresponds to the given value of&nbsp;<i>K</i>. Do not use operations of allocating and freeing memory.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано число&nbsp;<i>K</i> (&gt;&nbsp;0) и указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы непустого двусвязного списка. Осуществить <i>циклический сдвиг</i> элементов списка на <i>K</i>&nbsp;позиций назад (т.&nbsp;е. в направлении от конца к началу списка) и вывести указатели на первый и последний элементы полученного списка. Для выполнения циклического сдвига преобразовать исходный список в циклический (см. задание Dynamic55), после чего &#171;разорвать&#187; его в позиции, соответствующей данному значению&nbsp;<i>K</i>. Операции выделения и освобождения памяти не использовать.

---

## Dynamic 59
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given (if the list is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TList that is a record with three fields&#8212;<i>First</i>, <i>Last</i>, <i>Current</i>&#8212;of PNode type (the fields refer to the <i>first</i>, <i>last</i>, and <i>current</i> component of a doubly linked list respectively). Also write a procedure InsertLast(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the end of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the end of the given list (in the same order). Output the new addresses of the first, last, and current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на первый, последний и текущий элементы двусвязного списка (если список является пустым, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;NULL). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Описать тип TList &#8212; запись с полями First, Last и Current типа PNode (поля указывают соответственно на <i>первый</i>, <i>последний</i> и <i>текущий</i> элементы списка) &#8212; и процедуру InsertLast(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со значением&nbsp;<i>D</i> в конец списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TList, <i>D</i> &#8212; входной параметр целого типа). Добавленный элемент становится текущим. С помощью этой процедуры добавить в конец исходного списка данный набор чисел (в том же порядке) и вывести новые адреса его первого, последнего и текущего элементов.

---

## Dynamic 60
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given (if the list is empty then the pointers equal NULL). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Using the TList type (see Dynamic59), write a procedure InsertFirst(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the beginning of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the beginning of the given list (a component with the last value must be the first component of the resulting list). Output the new addresses of the first, last, and current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на первый, последний и текущий элементы двусвязного списка (если список является пустым, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;<i>P</i><sub>3</sub>&nbsp;=&nbsp;NULL). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Используя тип TList (см. задание Dynamic59), описать процедуру InsertFirst(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со значением&nbsp;<i>D</i> в начало списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TList, <i>D</i> &#8212; входной параметр целого типа). Добавленный элемент становится текущим. С помощью этой процедуры добавить в начало исходного списка данный набор чисел (добавленные числа будут располагаться в списке в обратном порядке) и вывести новые адреса его первого, последнего и текущего элементов.

---

## Dynamic 61
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list and five integers are given. Using the TList type (see Dynamic59), write a procedure InsertBefore(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> before the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new addresses of the first, last, and current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан непустой двусвязный список, первый, последний и текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Также даны пять чисел. Используя тип TList (см. задание Dynamic59), описать процедуру InsertBefore(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со значением&nbsp;<i>D</i> перед текущим элементом списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TList, <i>D</i> &#8212; входной параметр целого типа). Вставленный элемент становится текущим. С помощью этой процедуры вставить пять данных чисел в исходный список и вывести новые адреса его первого, последнего и текущего элементов.

---

## Dynamic 62
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list and five integers are given. Using the TList type (see Dynamic59), write a procedure InsertAfter(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> after the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TList type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new addresses of the first, last, and current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан непустой двусвязный список, первый, последний и текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Также даны пять чисел. Используя тип TList (см. задание Dynamic59), описать процедуру InsertAfter(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со значением&nbsp;<i>D</i> после текущего элемента списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TList, <i>D</i> &#8212; входной параметр целого типа). Вставленный элемент становится текущим. С помощью этой процедуры вставить пять данных чисел в исходный список и вывести новые адреса его первого, последнего и текущего элементов.

---

## Dynamic 63
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write three procedures: a procedure ToFirst(<i>L</i>) makes the first component of a list&nbsp;<i>L</i> the current one; a procedure ToNext(<i>L</i>) makes the component, which follows the current component of a list&nbsp;<i>L</i>, the new current one (provided that such a component exists); a procedure SetData(<i>L</i>,&nbsp;<i>D</i>) assigns a new integer value&nbsp;<i>D</i> to the current component of a list&nbsp;<i>L</i>. Also write a logical function IsLast(<i>L</i>) that returns true if the current component of a list&nbsp;<i>L</i> is the last component, and false otherwise. A record&nbsp;<i>L</i> of TList type is an input and output parameter of the ToFirst and ToNext procedure and is an input parameter of the SetData procedure and the IsLast function. Using these procedures and function, assign zero value to the list components with odd order numbers. Output the amount of list components and also output addresses of the first, last, and current component of the resulting list (the current component should be the last one).
#### ![ru](https://img.shields.io/badge/RU-blue) Дан непустой двусвязный список, первый, последний и текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Используя тип TList (см. задание Dynamic59), описать процедуры ToFirst(<i>L</i>) (делает текущим первый элемент списка&nbsp;<i>L</i>), ToNext(<i>L</i>) (делает текущим в списке&nbsp;<i>L</i> следующий элемент, если он существует), SetData(<i>L</i>,&nbsp;<i>D</i>) (присваивает текущему элементу списка&nbsp;<i>L</i> значение&nbsp;<i>D</i> целого типа) и функцию IsLast(<i>L</i>) логического типа (возвращает true, если текущий элемент списка&nbsp;<i>L</i> является его последним элементом, и false в противном случае). Параметр&nbsp;<i>L</i> имеет тип TList; в процедурах ToFirst и ToNext он является входным и выходным. С помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с нечетными номерами и вывести количество элементов в списке, а также новые адреса его первого, последнего и текущего элементов (текущим элементом должен стать последний элемент списка).

---

## Dynamic 64
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write two procedures: a procedure ToLast(<i>L</i>) makes the last component of a list&nbsp;<i>L</i> the current one; a procedure ToPrev(<i>L</i>) makes the component, which precedes the current component of a list&nbsp;<i>L</i>, the new current one (provided that such a component exists). Also write two functions: an integer function GetData(<i>L</i>) returns the value of the current component of a list&nbsp;<i>L</i>; a logical function IsFirst(<i>L</i>) returns true if the current component of a list&nbsp;<i>L</i> is the first component, and false otherwise. A record&nbsp;<i>L</i> of TList type is an input and output parameter of the ToLast and ToPrev procedure and is an input parameter of the GetData and IsFirst function. Using these procedures and functions, browse all list components from the end toward the beginning of the list and output their values that are even numbers. Also output the amount of list components.
#### ![ru](https://img.shields.io/badge/RU-blue) Дан непустой двусвязный список, первый, последний и текущий элементы которого имеют адреса&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub>. Используя тип TList (см. задание Dynamic59), описать процедуры ToLast(<i>L</i>) (делает текущим последний элемент списка&nbsp;<i>L</i>), ToPrev(<i>L</i>) (делает текущим в списке&nbsp;<i>L</i> предыдущий элемент, если он существует) и функции GetData(<i>L</i>) целого типа (возвращает значение текущего элемента списка&nbsp;<i>L</i>), IsFirst(<i>L</i>) логического типа (возвращает true, если текущий элемент списка&nbsp;<i>L</i> является его первым элементом, и false в противном случае). Параметр&nbsp;<i>L</i> имеет тип TList; в процедурах ToLast и ToPrev он является входным и выходным. С помощью этих процедур и функций вывести все четные значения элементов исходного списка, просматривая список с конца. Вывести также количество элементов в списке.

---

## Dynamic 65
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a doubly linked list are given. The list contains at least five components. Using the TList type (see Dynamic59), write an integer function DeleteCurrent(<i>L</i>) that removes the current component of a list&nbsp;<i>L</i>, releases memory allocated for the component being removed, and returns the value of this component (a record&nbsp;<i>L</i> of TList type is an input and output parameter). If the next component of the list&nbsp;<i>L</i> exists then it becomes the new current component, otherwise the last component becomes the new current one. Using this function, remove five components from the given list and output their values. Also output the new addresses of the first, last, and current component of the resulting list (if the resulting list will be empty then output NULL three times).
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на первый, последний и текущий элементы двусвязного списка, содержащего не менее пяти элементов. Используя тип TList (см. задание Dynamic59), описать функцию DeleteCurrent(<i>L</i>) целого типа, удаляющую из списка <i>L</i> текущий элемент и возвращающую его значение (<i>L</i> &#8212; входной и выходной параметр типа TList). После удаления элемента текущим становится следующий элемент или, если следующего элемента не существует, последний элемент списка. Функция также освобождает память, занимаемую удаленным элементом. С помощью этой функции удалить из исходного списка пять элементов и вывести их значения. Вывести также новые адреса первого, последнего и текущего элементов списка (для пустого списка вывести три константы&nbsp;NULL).

---

## Dynamic 66
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, and&nbsp;<i>P</i><sub>3</sub> to the first, last, and current component of a nonempty doubly linked list are given. Using the TList type (see Dynamic59), write a procedure SplitList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that moves some components of a list&nbsp;<i>L</i><sub>1</sub> into a new list&nbsp;<i>L</i><sub>2</sub>: components between the current and last component inclusively must be moved (as a result, the list&nbsp;<i>L</i><sub>1</sub> will be split into two parts; the first part may be empty). A record&nbsp;<i>L</i><sub>1</sub> of TList type is an input and output parameter, a record&nbsp;<i>L</i><sub>2</sub> of the same type is an output parameter. The first component of each nonempty resulting list becomes the current component of this list. The procedure should not use operations of allocating and freeing memory. Using this procedure, split the given list into two lists and output the addresses of the first, last, and current component of each resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub>, <i>P</i><sub>2</sub> и&nbsp;<i>P</i><sub>3</sub> на первый, последний и текущий элементы непустого двусвязного списка. Используя тип TList (см. задание Dynamic59), описать процедуру SplitList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая переносит элементы списка&nbsp;<i>L</i><sub>1</sub> от текущего до последнего в новый список&nbsp;<i>L</i><sub>2</sub> (таким образом, список&nbsp;<i>L</i><sub>1</sub> делится на две части, причем первая часть может оказаться пустой). Параметры процедуры имеют тип TList; первый параметр является входным и выходным, второй &#8212; выходным. Текущими элементами непустых результирующих списков становятся их первые элементы. Операции выделения и освобождения памяти в процедуре не использовать. С помощью этой процедуры разбить исходный список на два и вывести адреса первого, последнего и текущего элементов полученных списков.

---

## Dynamic 67
#### ![en](https://img.shields.io/badge/EN-blue) Pointers to the first, last, and current component of two nonempty doubly linked lists are given. Using the TList type (see Dynamic59), write a procedure AddList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that inserts all components of a list&nbsp;<i>L</i><sub>1</sub> (in the same order) at the end of a list&nbsp;<i>L</i><sub>2</sub>; as a result, the list&nbsp;<i>L</i><sub>1</sub> will be empty. The first component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, insert the first given list at the end of the second one and output the addresses of the first, last, and current component of the combined list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели на первый, последний и текущий элементы двух непустых двусвязных списков. Используя тип TList (см. задание Dynamic59), описать процедуру AddList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая добавляет все элементы из списка&nbsp;<i>L</i><sub>1</sub> (в том же порядке) в конец списка&nbsp;<i>L</i><sub>2</sub>; в результате список&nbsp;<i>L</i><sub>1</sub> становится пустым. Текущим элементом списка&nbsp;<i>L</i><sub>2</sub> становится первый из добавленных элементов. Оба параметра процедуры имеют тип TList и являются входными и выходными. Операции выделения и освобождения памяти в процедуре не использовать. С помощью этой процедуры добавить первый из исходных списков в конец второго и вывести адреса первого, последнего и текущего элементов объединенного списка.

---

## Dynamic 68
#### ![en](https://img.shields.io/badge/EN-blue) Pointers to the first, last, and current component of two nonempty doubly linked lists are given. Using the TList type (see Dynamic59), write a procedure InsertList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that inserts all components of a list&nbsp;<i>L</i><sub>1</sub> (in the same order) before the current component of a list&nbsp;<i>L</i><sub>2</sub>; as a result, the list&nbsp;<i>L</i><sub>1</sub> will be empty. The first component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, insert the first given list before the current component of the second one and output the addresses of the first, last, and current component of the combined list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели на первый, последний и текущий элементы двух непустых двусвязных списков. Используя тип TList (см. задание Dynamic59), описать процедуру InsertList(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая вставляет все элементы из списка&nbsp;<i>L</i><sub>1</sub> (в том же порядке) в список&nbsp;<i>L</i><sub>2</sub> перед его текущим элементом; в результате список&nbsp;<i>L</i><sub>1</sub> становится пустым. Текущим элементом списка&nbsp;<i>L</i><sub>2</sub> становится первый из вставленных элементов. Оба параметра процедуры имеют тип TList и являются входными и выходными. Операции выделения и освобождения памяти в процедуре не использовать. С помощью этой процедуры вставить первый из исходных списков в текущую позицию второго и вывести адреса первого, последнего и текущего элементов объединенного списка.

---

## Dynamic 69
#### ![en](https://img.shields.io/badge/EN-blue) Pointers to the first, last, and current component of two doubly linked lists are given; the second list may be empty. Using the TList type (see Dynamic59), write a procedure MoveCurrent(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>) that removes the current component from a list&nbsp;<i>L</i><sub>1</sub> and inserts this component after the current component of a list&nbsp;<i>L</i><sub>2</sub>. If the next component of the list&nbsp;<i>L</i><sub>1</sub> exists then it becomes the new current component of this list, otherwise the last component becomes the new current one; the component being inserted becomes the current component of the list&nbsp;<i>L</i><sub>2</sub>. Records&nbsp;<i>L</i><sub>1</sub> and&nbsp;<i>L</i><sub>2</sub> of TList type are input and output parameters. The procedure should not use operations of allocating and freeing memory. Using this procedure, move the current component of the first given list into the second one and output the addresses of the first, last, and current component of each resulting list (if the first resulting list will be empty then output NULL three times for this list).
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели на первый, последний и текущий элементы двух двусвязных списков (второй список может быть пустым). Используя тип TList (см. задание Dynamic59), описать процедуру MoveCurrent(<i>L</i><sub>1</sub>,&nbsp;<i>L</i><sub>2</sub>), которая перемещает текущий элемент списка&nbsp;<i>L</i><sub>1</sub> в список&nbsp;<i>L</i><sub>2</sub> (элемент вставляется после текущего элемента списка&nbsp;<i>L</i><sub>2</sub> и сам становится текущим; в списке&nbsp;<i>L</i><sub>1</sub> текущим становится следующий элемент или, если следующего элемента не существует, последний элемент). Оба параметра процедуры имеют тип TList и являются входными и выходными. Операции выделения и освобождения памяти в процедуре не использовать. С помощью этой процедуры переместить текущий элемент первого списка во второй и вывести адреса первого, последнего и текущего элементов полученных списков.

---

## Dynamic 70
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the first and last component of a doubly linked list are given (a doubly linked list is implemented by a chain of linked nodes of TNode type, the <i>Prev</i> field of the first node and the <i>Next</i> field of the last node are equal to NULL); if the list is empty then the pointers equal NULL. Transform the given list into the circular list (see Dynamic55) with a <i>barrier component</i>. The barrier component has zero value and is linked with the first and last component of the given list by the <i>Next</i> and <i>Prev</i> field respectively (if the given list is empty then the <i>Next</i> and <i>Prev</i> field of the barrier component must refer to the barrier component itself). Output the address of the barrier component of the resulting list. Use the operation of allocating memory only for creation of the barrier component.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на первый и последний элементы двусвязного списка, реализованного в виде цепочки узлов, ограниченной по краям нулевыми указателями (если список пуст, то <i>P</i><sub>1</sub>&nbsp;=&nbsp;<i>P</i><sub>2</sub>&nbsp;=&nbsp;NULL). Преобразовать исходный список в <i>циклический список</i> (см. задание Dynamic55), снабженный <i>барьерным элементом</i>. Барьерный элемент должен иметь значение&nbsp;0 и быть связан своими полями Next и Prev с первым и последним элементом исходного списка (в случае пустого исходного списка поля Next и Prev барьерного элемента должны указывать на сам барьерный элемент). Вывести указатель на барьерный элемент полученного списка. Операцию выделения памяти использовать только для создания барьерного элемента.

---

## Dynamic 71
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given (see the <i>barrier component</i> definition in Dynamic70). Move the given list components that are between the current and last component (inclusively) to a new list with the barrier component. If the current component of the given list is its barrier component then the new list must be empty (that is, it must contain the barrier component only). Output the address of the barrier component of the new list. Use the operation of allocating memory only for creation of the barrier component of the new list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка (о списке с барьерным элементом см. задание Dynamic70). Разбить список на два, перенеся во второй список все элементы от текущего до последнего и добавив ко второму списку барьерный элемент. Если текущий элемент исходного списка является барьерным элементом, то второй список должен быть пустым (т.&nbsp;е. состоять только из барьерного элемента). Вывести указатель на барьерный элемент второго списка. Операцию выделения памяти использовать только для создания барьерного элемента второго списка.

---

## Dynamic 72
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier components of two doubly linked lists are given (see the <i>barrier component</i> definition in Dynamic70). Combine the given lists by linking the last component of the first list with the first component of the second list. Use the barrier component of the first list as the barrier component of the combined list. Output the addresses of the first and last component of the combined list (if the combined list will be empty then output the address of its barrier component twice). After removing the superfluous barrier component (of the second list) release the memory allocated for this component.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерные элементы двух двусвязных списков (о списке с барьерным элементом см. задание Dynamic70). Объединить исходные списки, связав конец первого и начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент первого списка). Вывести указатели на первый и последний элементы объединенного списка (если объединенный список является пустым, то дважды вывести указатель на его барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им память.

---

## Dynamic 73
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier components of two doubly linked lists are given (see the <i>barrier component</i> definition in Dynamic70). Combine the given lists by linking the last component of the first list with the first component of the second list. Use the barrier component of the second list as the barrier component of the combined list. Output the addresses of the first and last component of the combined list (if the combined list will be empty then output the address of its barrier component twice). After removing the superfluous barrier component (of the first list) release the memory allocated for this component.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерные элементы двух двусвязных списков (о списке с барьерным элементом см. задание Dynamic70). Объединить исходные списки, связав конец первого и начало второго списка (барьерным элементом объединенного списка должен остаться барьерный элемент второго списка). Вывести указатели на первый и последний элементы объединенного списка (если объединенный список является пустым, то дважды вывести указатель на его барьерный элемент). После удаления лишнего барьерного элемента освободить занимаемую им память.

---

## Dynamic 74
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given (see the <i>barrier component</i> definition in Dynamic70). Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Define a new type called TListB that is a record with two fields, <i>Barrier</i> and <i>Current</i>, of PNode type (the fields refer to the <i>barrier</i> and <i>current</i> component of a doubly linked list respectively). Also write a procedure LBInsertLast(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the end of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the end of the given list (in the same order). Output the new address of the current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка (о списке с барьерным элементом см. задание Dynamic70). Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Описать тип TListB &#8212; запись с полями Barrier и Current типа PNode (поля указывают соответственно на <i>барьерный</i> и <i>текущий</i> элементы списка) &#8212; и процедуру LBInsertLast(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со значением&nbsp;<i>D</i> в конец списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TListB, <i>D</i> &#8212; входной параметр целого типа). Добавленный элемент становится текущим. С помощью этой процедуры добавить в конец исходного списка данный набор чисел (в том же порядке) и вывести адрес текущего элемента полученного списка.

---

## Dynamic 75
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Also an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a sequence of <i>N</i>&nbsp;integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertFirst(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> at the beginning of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert all elements of the given sequence at the beginning of the given list (a component with the last value must be the first component of the resulting list). Output the new address of the current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка. Также дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Используя тип TListB (см. задание Dynamic74), описать процедуру LBInsertFirst(<i>L</i>,&nbsp;<i>D</i>), которая добавляет новый элемент со значением&nbsp;<i>D</i> в начало списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TListB, <i>D</i> &#8212; входной параметр целого типа). Добавленный элемент становится текущим. С помощью этой процедуры добавить в начало исходного списка данный набор чисел (добавленные числа будут располагаться в списке в обратном порядке) и вывести адрес текущего элемента полученного списка.

---

## Dynamic 76
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list and five integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertBefore(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> before the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new address of the current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см. задание Dynamic74), описать процедуру LBInsertBefore(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со значением&nbsp;<i>D</i> перед текущим элементом списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TListB, <i>D</i> &#8212; входной параметр целого типа). Вставленный элемент становится текущим. С помощью этой процедуры вставить пять данных чисел в исходный список и вывести новый адрес его текущего элемента.

---

## Dynamic 77
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list and five integers are given. Using the TListB type (see Dynamic74), write a procedure LBInsertAfter(<i>L</i>,&nbsp;<i>D</i>) that inserts a new component with the value&nbsp;<i>D</i> after the current component of a list&nbsp;<i>L</i> (a record&nbsp;<i>L</i> of TListB type is an input and output parameter, an integer&nbsp;<i>D</i> is an input parameter). The component being inserted becomes the current component of the list. Using this procedure, insert five given integers into the given list. Output the new address of the current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка. Также даны пять чисел. Используя тип TListB (см. задание Dynamic74), описать процедуру LBInsertAfter(<i>L</i>,&nbsp;<i>D</i>), которая вставляет новый элемент со значением&nbsp;<i>D</i> после текущего элемента списка&nbsp;<i>L</i> (<i>L</i> &#8212; входной и выходной параметр типа TListB, <i>D</i> &#8212; входной параметр целого типа). Вставленный элемент становится текущим. С помощью этой процедуры вставить пять данных чисел в исходный список и вывести новый адрес его текущего элемента.

---

## Dynamic 78
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Using the TListB type (see Dynamic74), write three procedures: a procedure LBToFirst(<i>L</i>) makes the first component of a list&nbsp;<i>L</i> the current one; a procedure LBToNext(<i>L</i>) makes the component, which follows the current component of a list&nbsp;<i>L</i>, the new current one; a procedure LBSetData(<i>L</i>,&nbsp;<i>D</i>) assigns a new integer value&nbsp;<i>D</i> to the current component of a list&nbsp;<i>L</i> (provided that the current component is not the barrier one). Also write a logical function IsBarrier(<i>L</i>) that returns true if the current component of a list&nbsp;<i>L</i> is the barrier component, and false otherwise. A record&nbsp;<i>L</i> of TListB type is an input and output parameter of the LBToFirst and LBToNext procedure and is an input parameter of the LBSetData procedure and the IsBarrier function. Using these procedures and function, assign zero value to the list components with odd order numbers. Output the amount of list components and the address of the current component of the resulting list (the current component should be the barrier one). The components are numbered from the first component, which has the order number&nbsp;1; the barrier component is not numbered and should not be counted.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка. Используя тип TListB (см. задание Dynamic74), описать процедуры LBToFirst(<i>L</i>) (делает текущим первый элемент списка&nbsp;<i>L</i>), LBToNext(<i>L</i>) (делает текущим в списке&nbsp;<i>L</i> следующий элемент), LBSetData(<i>L</i>,&nbsp;<i>D</i>) (присваивает текущему элементу списка&nbsp;<i>L</i> значение&nbsp;<i>D</i> целого типа, если данный элемент не является барьерным) и функцию IsBarrier(<i>L</i>) логического типа (возвращает true, если текущий элемент списка&nbsp;<i>L</i> является его барьерным элементом, и false в противном случае). Параметр&nbsp;<i>L</i> имеет тип TListB; в процедурах LBToFirst и LBToNext он является входным и выходным. С помощью этих процедур и функций присвоить нулевые значения элементам исходного списка с нечетными номерами и вывести количество элементов в списке, а также новый адрес текущего элемента списка (текущим элементом списка должен стать его барьерный элемент). Нумерация ведется от первого элемента списка; барьерный элемент не нумеруется и не учитывается при подсчете элементов.

---

## Dynamic 79
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a doubly linked list are given. Using the TListB type (see Dynamic74), write two procedures: a procedure LBToLast(<i>L</i>) makes the last component of a list&nbsp;<i>L</i> the current one; a procedure LBToPrev(<i>L</i>) makes the component, which precedes the current component of a list&nbsp;<i>L</i>, the new current one. Also write an integer function LBGetData(<i>L</i>) that returns the value of the current component of a list&nbsp;<i>L</i>. A record&nbsp;<i>L</i> of TListB type is an input and output parameter of the LBToLast and LBToPrev procedure and is an input parameter of the LBGetData function. Using these procedures and function and also the IsBarrier function from the task Dynamic78, browse all list components from the end toward the beginning of the list and output their values that are even numbers. Also output the amount of list components. The barrier component should not be processed and counted.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы двусвязного списка. Используя тип TListB (см. задание Dynamic74), описать процедуры LBToLast(<i>L</i>) (делает текущим последний элемент списка&nbsp;<i>L</i>), LBToPrev(<i>L</i>) (делает текущим в списке&nbsp;<i>L</i> предыдущий элемент) и функцию LBGetData(<i>L</i>) целого типа (возвращает значение текущего элемента списка&nbsp;<i>L</i>). Параметр&nbsp;<i>L</i> имеет тип TListB; в процедурах LBToLast и LBToPrev он является входным и выходным. С помощью этих процедур и функций, а также функции IsBarrier из задания Dynamic78, вывести все четные значения элементов исходного списка, просматривая список с конца. Вывести также количество элементов в списке. Барьерный элемент не обрабатывается и не учитывается при подсчете элементов.

---

## Dynamic 80
#### ![en](https://img.shields.io/badge/EN-blue) Pointers&nbsp;<i>P</i><sub>1</sub> and&nbsp;<i>P</i><sub>2</sub> to the barrier and current component of a nonempty doubly linked list are given; the current component is not the barrier one. Using the TListB type (see Dynamic74), write an integer function LBDeleteCurrent(<i>L</i>) that removes the current component of a list&nbsp;<i>L</i>, releases memory allocated for the component being removed, and returns the value of this component (a record&nbsp;<i>L</i> of TListB type is an input and output parameter). If the next component of the list&nbsp;<i>L</i> is not the barrier one then it becomes the new current component, otherwise the previous component becomes the new current one. If the current component is the barrier one then the function performs no actions and returns&nbsp;0. Using this function and also the IsBarrier function from the task Dynamic78, remove five components from the given list (or all components if their amount is less than five) and output their values. Also output the new address of the current component of the resulting list.
#### ![ru](https://img.shields.io/badge/RU-blue) Даны указатели&nbsp;<i>P</i><sub>1</sub> и&nbsp;<i>P</i><sub>2</sub> на барьерный и текущий элементы непустого двусвязного списка, причем текущий элемент не совпадает с барьерным. Используя тип TListB (см. задание Dynamic74), описать функцию LBDeleteCurrent(<i>L</i>) целого типа, удаляющую из списка&nbsp;<i>L</i> текущий элемент и возвращающую его значение (<i>L</i> &#8212; входной и выходной параметр типа TListB). Текущим становится следующий элемент или, если следующий элемент является барьерным, предыдущий элемент списка. Функция также освобождает память, занимаемую удаленным элементом. Если текущим элементом является барьерный элемент, то функция не выполняет никаких действий и возвращает&nbsp;0. С помощью этой функции, а также функции IsBarrier из задания Dynamic78, удалить из исходного списка пять элементов (или все элементы, если их менее пяти) и вывести их значения. Вывести также новый адрес текущего элемента списка.

---

