## Recur 1
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive real-valued function Fact(<i>N</i>) that returns the value of <i>N-factorial</i>:<i>N</i>!&nbsp;=&nbsp;1&#183;2&#183;&#8230;&#183;<i>N</i>,where&nbsp;<i>N</i> (&gt;&nbsp;0) is an integer parameter. Using this function, output factorials of five given integers.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Fact(<i>N</i>) вещественного типа, вычисляющую значение <i>факториала</i><i>N</i>!&nbsp;=&nbsp;1&#183;2&#183;&#8230;&#183;<i>N</i>(<i>N</i>&nbsp;&gt;&nbsp;0 &#8212; параметр целого типа). С помощью этой функции вычислить факториалы пяти данных чисел.

---

## Recur 2
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive real-valued function Fact2(<i>N</i>) that returns the value of <i>double factorial</i> of&nbsp;<i>N</i>:<i>N</i>!!&nbsp;=&nbsp;<i>N</i>&#183;(<i>N</i>&#8722;2)&#183;(<i>N</i>&#8722;4)&#183;&#8230;,where&nbsp;<i>N</i> (&gt;&nbsp;0) is an integer parameter; the last factor of the product equals&nbsp;2 if&nbsp;<i>N</i> is an even number, and&nbsp;1 otherwise. Using this function, output double factorials of five given integers.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Fact2(<i>N</i>) вещественного типа, вычисляющую значение <i>двойного факториала</i><i>N</i>!!&nbsp;=&nbsp;<i>N</i>&#183;(<i>N</i>&#8722;2)&#183;(<i>N</i>&#8722;4)&#183;&#8230;(<i>N</i>&nbsp;&gt;&nbsp;0 &#8212; параметр целого типа; последний сомножитель в произведении равен&nbsp;2, если <i>N</i> &#8212; четное число, и&nbsp;1, если <i>N</i> &#8212; нечетное). С помощью этой функции вычислить двойные факториалы пяти данных чисел.

---

## Recur 3
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive real-valued function PowerN(<i>X</i>,&nbsp;<i>N</i>) that returns the power <i>X</i><sup><i>N</i></sup> (<i>X</i>&nbsp;&#8800;&nbsp;0 is a real number, <i>N</i>&nbsp;is an integer) calculated as follows: <i>X</i><sup>&nbsp;0</sup>&nbsp;=&nbsp;1,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;(<i>X</i><sup>&nbsp;<i>N</i> <i>d</i><i>i</i><i>v</i> 2</sup>)<sup>2</sup> if <i>N</i> is a positive even number,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;<i>X</i>&#183;<i>X</i><sup>&nbsp;<i>N</i>&#8722;1</sup> if <i>N</i> is a positive odd number,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;1/<i>X</i><sup>&nbsp;&#8722;<i>N</i></sup> if <i>N</i>&nbsp;&lt;&nbsp;0,where &#34;div&#34; denotes the operator of <i>integer division</i>. Using this function, output powers <i>X</i><sup><i>N</i></sup> for a given real number&nbsp;<i>X</i> and five given integers&nbsp;<i>N</i>.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию PowerN(<i>X</i>,&nbsp;<i>N</i>) вещественного типа, находящую значение <i>N</i>-й степени числа&nbsp;<i>X</i> по формулам: <i>X</i><sup>&nbsp;0</sup>&nbsp;=&nbsp;1,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;(<i>X</i><sup>&nbsp;<i>N</i>/2</sup>)<sup>2</sup> при <i>четных</i> <i>N</i>&nbsp;&gt;&nbsp;0, &nbsp; &nbsp; &nbsp; &nbsp;<i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;<i>X</i>&#183;<i>X</i><sup>&nbsp;<i>N</i>&#8722;1</sup> при <i>нечетных</i> <i>N</i>&nbsp;&gt;&nbsp;0,<br><i>X</i><sup>&nbsp;<i>N</i></sup>&nbsp;=&nbsp;1/<i>X</i><sup>&nbsp;&#8722;<i>N</i></sup> при <i>N</i>&nbsp;&lt;&nbsp;0(<i>X</i>&nbsp;&#8800;&nbsp;0 &#8212; вещественное число, <i>N</i> &#8212; целое; в формуле для четных&nbsp;<i>N</i> должна использоваться операция <i>целочисленного деления</i>). С помощью этой функции найти значения <i>X</i><sup>&nbsp;<i>N</i></sup> для данного&nbsp;<i>X</i> при пяти данных значениях&nbsp;<i>N</i>.

---

## Recur 4
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function Fib1(<i>N</i>) that returns the Fibonacci number&nbsp;<i>F</i><sub><i>N</i></sub> (<i>N</i>&nbsp;is a positive integer). The <i>Fibonacci numbers</i>&nbsp;<i>F</i><sub><i>K</i></sub> are defined as: <i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#8722;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#8722;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#8230;&nbsp;.Using the function Fib1, find the Fibonacci numbers&nbsp;<i>F</i><sub><i>N</i></sub> for five given integers&nbsp;<i>N</i>; output the value of each Fibonacci number and also the amount of the recursive function calls, which are required for its calculation.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Fib1(<i>N</i>) целого типа, вычисляющую <i>N</i>-й элемент последовательности <i>чисел Фибоначчи</i> (<i>N</i> &#8212; целое число): <i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#8722;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#8722;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#8230;&nbsp;.С помощью этой функции найти пять чисел Фибоначчи с данными номерами, и вывести эти числа вместе с количеством рекурсивных вызовов функции Fib1, потребовавшихся для их нахождения.

---

## Recur 5
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function Fib2(<i>N</i>) that returns the Fibonacci number&nbsp;<i>F</i><sub><i>N</i></sub> (<i>N</i>&nbsp;is a positive integer). The <i>Fibonacci numbers</i>&nbsp;<i>F</i><sub><i>K</i></sub> are defined as: <i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#8722;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#8722;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#8230;&nbsp;.The integer&nbsp;<i>N</i> is assumed to be not greater than&nbsp;20. Decrease the amount of recursive calls of the function Fib2 (in comparison with the Fib1 function from the task Recur4) by means of using an additional array of integers that should store the Fibonacci numbers <i>having been calculated</i>. Using the Fib2 function, output the Fibonacci numbers&nbsp;<i>F</i><sub><i>N</i></sub> for five given integers&nbsp;<i>N</i>.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Fib2(<i>N</i>) целого типа, вычисляющую <i>N</i>-й элемент последовательности <i>чисел Фибоначчи</i> (<i>N</i> &#8212; целое число): <i>F</i><sub>1</sub>&nbsp;=&nbsp;<i>F</i><sub>2</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>F</i><sub><i>K</i></sub>&nbsp;=&nbsp;<i>F</i><sub><i>K</i>&#8722;2</sub>&nbsp;+&nbsp;<i>F</i><sub><i>K</i>&#8722;1</sub>, &nbsp; &nbsp;<i>K</i>&nbsp;=&nbsp;3,&nbsp;4,&nbsp;&#8230;&nbsp;.Считать, что номер&nbsp;<i>N</i> не превосходит&nbsp;20. Для уменьшения количества рекурсивных вызовов по сравнению с функцией Fib1 (см. задание Recur4) создать вспомогательный массив для хранения <i>уже вычисленных</i> чисел Фибоначчи и обращаться к нему при выполнении функции Fib2. С помощью функции Fib2 найти пять чисел Фибоначчи с данными номерами.

---

## Recur 6
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function Combin1(<i>N</i>,&nbsp;<i>K</i>) that returns&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) (the <i>number of combinations</i> of&nbsp;<i>N</i> objects taken&nbsp;<i>K</i> at a time) using the following recursive relations (<i>N</i> and&nbsp;<i>K</i> are integers, <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;&#8804;&nbsp;<i>K</i>&nbsp;&#8804;&nbsp;<i>N</i>): <i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1) &nbsp; &nbsp;if 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.Using the function Combin1, find the numbers&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) for a given integer&nbsp;<i>N</i> and five given integers&nbsp;<i>K</i>; output the value of each number and also the amount of the recursive function calls, which are required for its calculation.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Combin1(<i>N</i>,&nbsp;<i>K</i>) целого типа, находящую <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) &#8212; <i>число сочетаний</i> из <i>N</i>&nbsp;элементов по&nbsp;<i>K</i> &#8212; с помощью рекуррентного соотношения: <i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1) &nbsp; &nbsp;при 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.Параметры функции &#8212; целые числа; <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;&#8804;&nbsp;<i>K</i>&nbsp;&#8804;&nbsp;<i>N</i>. Дано число&nbsp;<i>N</i> и пять различных значений&nbsp;<i>K</i>. Вывести числа&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) вместе с количеством рекурсивных вызовов функции Combin1, потребовавшихся для их нахождения.

---

## Recur 7
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function Combin2(<i>N</i>,&nbsp;<i>K</i>) that returns&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) (the <i>number of combinations</i> of&nbsp;<i>N</i> objects taken&nbsp;<i>K</i> at a time) using the following recursive relations (<i>N</i> and&nbsp;<i>K</i> are integers, <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;&#8804;&nbsp;<i>K</i>&nbsp;&#8804;&nbsp;<i>N</i>): <i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1) &nbsp; &nbsp;if 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.The integer&nbsp;<i>N</i> is assumed to be not greater than&nbsp;20. Decrease the amount of recursive calls of the function Combin2 (in comparison with the Combin1 function from the task Recur6) by means of using an additional two-dimensional array of integers that should store the numbers&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) <i>having been calculated</i>. Using the Combin2 function, output the numbers&nbsp;<i>C</i>(<i>N</i>,&nbsp;<i>K</i>) for a given integer&nbsp;<i>N</i> and five given integers&nbsp;<i>K</i>.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Combin2(<i>N</i>,&nbsp;<i>K</i>) целого типа, находящую <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) &#8212; <i>число сочетаний</i> из <i>N</i>&nbsp;элементов по&nbsp;<i>K</i> &#8212; с помощью рекуррентного соотношения: <i>C</i>(<i>N</i>,&nbsp;0)&nbsp;=&nbsp;C(<i>N</i>,&nbsp;<i>N</i>)&nbsp;=&nbsp;1,<br><i>C</i>(<i>N</i>,&nbsp;<i>K</i>)&nbsp;=&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>)&nbsp;+&nbsp;<i>C</i>(<i>N</i>&nbsp;&#8722;&nbsp;1,&nbsp;<i>K</i>&nbsp;&#8722;&nbsp;1) &nbsp; &nbsp;при 0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;<i>N</i>.Параметры функции &#8212; целые числа; <i>N</i>&nbsp;&gt;&nbsp;0, 0&nbsp;&#8804;&nbsp;<i>K</i>&nbsp;&#8804;&nbsp;<i>N</i>. Считать, что параметр&nbsp;<i>N</i> не превосходит&nbsp;20. Для уменьшения количества рекурсивных вызовов по сравнению с функцией Combin1 (см. задание Recur6) описать вспомогательный двумерный массив для хранения <i>уже вычисленных</i> чисел <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) и обращаться к нему при выполнении функции Combin2. С помощью функции Combin2 найти числа <i>C</i>(<i>N</i>,&nbsp;<i>K</i>) для данного значения&nbsp;<i>N</i> и пяти различных значений&nbsp;<i>K</i>.

---

## Recur 8
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive real-valued function RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) that returns an approximate value of a <i>K</i>-th root of&nbsp;<i>X</i> using the following formulas: <i>Y</i><sub>0</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>Y</i><sub><i>N</i>+1</sub>&nbsp;=&nbsp;<i>Y</i><sub><i>N</i></sub>&nbsp;&#8722;&nbsp;(<i>Y</i><sub><i>N</i></sub>&nbsp;&#8722;&nbsp;<i>X</i>/(<i>Y</i><sub><i>N</i></sub>)<sup><i>K</i>&#8722;1</sup>)/<i>K</i>,where&nbsp;<i>X</i> (&gt;&nbsp;0) is a real number, <i>K</i> (&gt;&nbsp;1), <i>N</i> (&gt;&nbsp;0) are integers, <i>Y</i><sub><i>N</i></sub> denotes RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) for a fixed values of&nbsp;<i>X</i> and&nbsp;<i>K</i>. Using this function, output approximate values of a <i>K</i>-th root of&nbsp;<i>X</i> for a given&nbsp;<i>X</i>, <i>K</i> and six integers&nbsp;<i>N</i>.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) вещественного типа, находящую приближенное значение корня <i>K</i>-й степени из числа&nbsp;<i>X</i> по формуле: <i>Y</i><sub>0</sub>&nbsp;=&nbsp;1, &nbsp; &nbsp; &nbsp; &nbsp;<i>Y</i><sub><i>N</i>+1</sub>&nbsp;=&nbsp;<i>Y</i><sub><i>N</i></sub>&nbsp;&#8722;&nbsp;(<i>Y</i><sub><i>N</i></sub>&nbsp;&#8722;&nbsp;<i>X</i>/(<i>Y</i><sub><i>N</i></sub>)<sup><i>K</i>&#8722;1</sup>)/<i>K</i>,где <i>Y</i><sub><i>N</i></sub> обозначает RootK(<i>X</i>,&nbsp;<i>K</i>,&nbsp;<i>N</i>) при фиксированных&nbsp;<i>X</i> и&nbsp;<i>K</i>. Параметры функции: <i>X</i> (&gt;&nbsp;0) &#8212; вещественное число, <i>K</i> (&gt;&nbsp;1) и&nbsp;<i>N</i> (&gt;&nbsp;0) &#8212; целые. С помощью функции RootK найти для данного числа&nbsp;<i>X</i> приближенные значения его корня <i>K</i>-й степени при шести данных значениях&nbsp;<i>N</i>.

---

## Recur 9
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function GCD(<i>A</i>,&nbsp;<i>B</i>) that returns the <i>greatest</i> <i>common divisor</i> of two positive integers&nbsp;<i>A</i> and&nbsp;<i>B</i>. Use the <i>Euclidean algorithm</i>: GCD(<i>A</i>,&nbsp;<i>B</i>)&nbsp;=&nbsp;GCD(<i>B</i>, <i>A</i>&nbsp;mod&nbsp;<i>B</i>), &nbsp; &nbsp;if <i>B</i>&nbsp;&#8800;&nbsp;0; &nbsp; &nbsp; &nbsp; &nbsp;GCD(<i>A</i>,&nbsp;0)&nbsp;=&nbsp;<i>A</i>,where &#34;mod&#34; denotes the operator of taking the remainder after integer division. Using this function, find the greatest common divisor for each of pairs (<i>A</i>,&nbsp;<i>B</i>), (<i>A</i>,&nbsp;<i>C</i>), (<i>A</i>,&nbsp;<i>D</i>) provided that integers&nbsp;<i>A</i>, <i>B</i>, <i>C</i>,&nbsp;<i>D</i> are given.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию GCD(<i>A</i>,&nbsp;<i>B</i>) целого типа, находящую <i>наибольший общий</i> <i>делитель</i> (НОД, greatest common divisor) двух целых положительных чисел&nbsp;<i>A</i> и&nbsp;<i>B</i>, используя <i>алгоритм Евклида</i>: НОД(<i>A</i>,&nbsp;<i>B</i>)&nbsp;=&nbsp;НОД(<i>B</i>, <i>A</i>&nbsp;mod&nbsp;<i>B</i>), &nbsp; &nbsp;<i>B</i>&nbsp;&#8800;&nbsp;0; &nbsp; &nbsp; &nbsp; &nbsp;НОД(<i>A</i>,&nbsp;0)&nbsp;=&nbsp;<i>A</i>,где &#171;mod&#187; обозначает операцию взятия остатка от деления. С помощью этой функции найти НОД(<i>A</i>,&nbsp;<i>B</i>), НОД(<i>A</i>,&nbsp;<i>C</i>), НОД(<i>A</i>,&nbsp;<i>D</i>), если даны числа&nbsp;<i>A</i>, <i>B</i>, <i>C</i>,&nbsp;<i>D</i>.

---

## Recur 10
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function DigitSum(<i>K</i>) that returns the sum of digits of an integer&nbsp;<i>K</i> (the loop statements should not be used). Using this function, output the sum of digits for each of five given integers.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию DigitSum(<i>K</i>) целого типа, которая находит сумму цифр целого числа&nbsp;<i>K</i>, не используя оператор цикла. С помощью этой функции найти суммы цифр для пяти данных целых чисел.

---

## Recur 11
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function MaxElem(<i>A</i>,&nbsp;<i>N</i>) that returns the maximal element of an array&nbsp;<i>A</i> of <i>N</i>&nbsp;integers (1&nbsp;&#8804;&nbsp;<i>N</i>&nbsp;&#8804;&nbsp;10; the loop statements should not be used). Using this function, output the maximal elements of three given arrays&nbsp;<i>A</i>, <i>B</i>,&nbsp;<i>C</i> whose sizes are&nbsp;<i>N</i><sub><i>A</i></sub>, <i>N</i><sub><i>B</i></sub>,&nbsp;<i>N</i><sub><i>C</i></sub> respectively.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию MaxElem(<i>A</i>, <i>N</i>) целого типа, которая находит максимальный элемент целочисленного массива&nbsp;<i>A</i> размера&nbsp;<i>N</i> (1&nbsp;&#8804;&nbsp;<i>N</i>&nbsp;&#8804;&nbsp;10), не используя оператор цикла. С помощью этой функции найти максимальные элементы массивов&nbsp;<i>A</i>, <i>B</i>,&nbsp;<i>C</i> размера&nbsp;<i>N</i><sub><i>A</i></sub>, <i>N</i><sub><i>B</i></sub>,&nbsp;<i>N</i><sub><i>C</i></sub> соответственно.

---

## Recur 12
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive integer function DigitCount(<i>S</i>) that returns the amount of digit characters in a string&nbsp;<i>S</i> (the loop statements should not be used). Using this function, output the amount of digit characters for each of five given strings.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию DigitCount(<i>S</i>) целого типа, которая находит количество цифр в строке&nbsp;<i>S</i>, не используя оператор цикла. С помощью этой функции найти количество цифр в каждой из пяти данных строк.

---

## Recur 13
#### ![en](https://img.shields.io/badge/EN-blue) Write a recursive logical function Palindrome(<i>S</i>) that returns true if a string&nbsp;<i>S</i> is a <i>palindrome</i> (i.&nbsp;e., it is read equally both from left to right and from right to left), and false otherwise; the loop statements should not be used. Output return values of this function for five given string parameters.
#### ![ru](https://img.shields.io/badge/RU-blue) Описать рекурсивную функцию Palindrome(<i>S</i>) логического типа, возвращающую true, если строка&nbsp;<i>S</i> является <i>палиндромом</i> (т.&nbsp;е. читается одинаково слева направо и справа налево), и false в противном случае. Оператор цикла в теле функции не использовать. Вывести значения функции Palindrome для пяти данных строк.

---

## Recur 14
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows: <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; | &lt;expression&gt;&nbsp;+&nbsp;&lt;digit&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;expression&gt;&nbsp;&#8722;&nbsp;&lt;digit&gt;</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#8722;&nbsp;&lt;цифра&gt;</table></p>

---

## Recur 15
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows: <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;term&gt; | &lt;expression&gt;&nbsp;+&nbsp;&lt;term&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;expression&gt;&nbsp;&#8722;&nbsp;&lt;term&gt;<tr><td align=left>&lt;term&gt;       <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; | &lt;term&gt;&nbsp;*&nbsp;&lt;digit&gt;</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;терм&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;терм&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#8722;&nbsp;&lt;терм&gt;<tr><td align=left>&lt;терм&gt;      <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | &lt;терм&gt;&nbsp;*&nbsp;&lt;цифра&gt;</table></p>

---

## Recur 16
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows: <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;term&gt; | &lt;expression&gt;&nbsp;+&nbsp;&lt;term&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;expression&gt;&nbsp;&#8722;&nbsp;&lt;term&gt;<tr><td align=left>&lt;term&gt;       <td align=center><tt>::=</tt> <td align=left>&lt;element&gt; | &lt;term&gt;&nbsp;*&nbsp;&lt;element&gt;<tr><td align=left>&lt;element&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; | (&lt;expression&gt;)</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;терм&gt; | &lt;выражение&gt;&nbsp;+&nbsp;&lt;терм&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt;&nbsp;&#8722;&nbsp;&lt;терм&gt;<tr><td align=left>&lt;терм&gt;      <td align=center><tt>::=</tt> <td align=left>&lt;элемент&gt; | &lt;терм&gt;&nbsp;*&nbsp;&lt;элемент&gt;<tr><td align=left>&lt;элемент&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | (&lt;выражение&gt;)</table></p>

---

## Recur 17
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows: <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;expression&gt;&lt;operator&gt;&lt;expression&gt;)<tr><td align=left>&lt;operator&gt;   <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом: <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;выражение&gt;&lt;знак&gt;&lt;выражение&gt;)<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p>

---

## Recur 18
#### ![en](https://img.shields.io/badge/EN-blue) A nonempty string&nbsp;<i>S</i> that represents an expression of integer type is given (see the expression definition in Recur17). Output true if the given expression is a correct one, otherwise output false.
#### ![ru](https://img.shields.io/badge/RU-blue) Проверить правильность выражения, заданного в виде непустой строки&nbsp;<i>S</i> (выражение определяется по тем же правилам, что и в задании Recur17). Если выражение составлено правильно, то вывести true, иначе вывести false.

---

## Recur 19
#### ![en](https://img.shields.io/badge/EN-blue) A nonempty string&nbsp;<i>S</i> that represents an expression of integer type is given (see the expression definition in Recur17). Output&nbsp;0 if the given expression is a correct one, otherwise output the order number of its first character that is invalid, superfluous or missing.
#### ![ru](https://img.shields.io/badge/RU-blue) Проверить правильность выражения, заданного в виде непустой строки&nbsp;<i>S</i> (выражение определяется по тем же правилам, что и в задании Recur17). Если выражение составлено правильно, то вывести&nbsp;0, в противном случае вывести номер первого ошибочного, лишнего или недостающего символа в строке&nbsp;<i>S</i>.

---

## Recur 20
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows (functions&nbsp;M and&nbsp;m return their maximal and minimal argument respectively): <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; | M(&lt;expression&gt;&nbsp;,&nbsp;&lt;expression&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>m(&lt;expression&gt;&nbsp;,&nbsp;&lt;expression&gt;)</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (функция&nbsp;M возвращает максимальный из своих параметров, а функция&nbsp;m &#8212; минимальный): <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>m(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></p>

---

## Recur 21
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of logical type, output the value of this expression. The expression is defined as follows (&#34;T&#34; means true, &#34;F&#34; means false): <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;expression&gt;&nbsp;,&nbsp;&lt;expression&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;expression&gt;&nbsp;,&nbsp;&lt;expression&gt;)</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение логического выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187; &#8212; true, &#171;F&#187; &#8212; false): <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></p>

---

## Recur 22
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of integer type, output the value of this expression. The expression is defined as follows (functions&nbsp;M and&nbsp;m return their maximal and minimal argument respectively): <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>&lt;digit&gt; | M(&lt;arguments&gt;) | m(&lt;arguments&gt;)<tr><td align=left>&lt;arguments&gt;  <td align=center><tt>::=</tt> <td align=left>&lt;expression&gt; | &lt;expression&gt;&nbsp;,&nbsp;&lt;arguments&gt;</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение целочисленного выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (функция&nbsp;M возвращает максимальный из своих параметров, а функция&nbsp;m &#8212; минимальный): <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;параметры&gt;) | m(&lt;параметры&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></p>

---

## Recur 23
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of logical type, output the value of this expression. The expression is defined as follows (&#34;T&#34; means true, &#34;F&#34; means false): <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;arguments&gt;) | Or(&lt;arguments&gt;)<tr><td align=left>&lt;arguments&gt;  <td align=center><tt>::=</tt> <td align=left>&lt;expression&gt; | &lt;expression&gt;&nbsp;,&nbsp;&lt;arguments&gt;</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение логического выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187; &#8212; true, &#171;F&#187; &#8212; false): <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;параметры&gt;) | Or(&lt;параметры&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></p>

---

## Recur 24
#### ![en](https://img.shields.io/badge/EN-blue) Given a string&nbsp;<i>S</i> that represents a correct expression of logical type, output the value of this expression. The expression is defined as follows (&#34;T&#34; means true, &#34;F&#34; means false): <table align="center"><tr><td align=left>&lt;expression&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;arguments&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;arguments&gt;) | Not(&lt;expression&gt;)<tr><td align=left>&lt;arguments&gt;  <td align=center><tt>::=</tt> <td align=left>&lt;expression&gt; | &lt;expression&gt;&nbsp;,&nbsp;&lt;arguments&gt;</table></p>
#### ![ru](https://img.shields.io/badge/RU-blue) Вывести значение логического выражения, заданного в виде строки&nbsp;<i>S</i>. Выражение определяется следующим образом (&#171;T&#187; &#8212; true, &#171;F&#187; &#8212; false): <table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>T | F | And(&lt;параметры&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>Or(&lt;параметры&gt;) | Not(&lt;выражение&gt;)<tr><td align=left>&lt;параметры&gt; <td align=center><tt>::=</tt> <td align=left>&lt;выражение&gt; | &lt;выражение&gt;&nbsp;,&nbsp;&lt;параметры&gt;</table></p>

---

## Recur 25
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given. Each internal node of the tree has&nbsp;<i>K</i> (&lt;&nbsp;10) children that are numbered from&nbsp;1 (the most left child) to&nbsp;<i>K</i> (the most right child). The number of the tree root is&nbsp;0. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves. Paths must be ordered from the <i>most left path</i> (&#34;011...1&#34;) to the <i>most right path</i> (for instance, &#34;033...3&#34; provided that K&nbsp;=&nbsp;3); the last nodes of path must be changed faster than the first ones.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет <i>K</i> (&lt;&nbsp;10) непосредственных потомков (нумеруются от&nbsp;1 до&nbsp;<i>K</i>). Корень дерева имеет номер&nbsp;0. Записать в текстовый файл с данным именем все возможные пути, ведущие от корня к листьям. Перебирать пути, начиная с &#171;самого левого&#187; и заканчивая &#171;самым правым&#187; (при этом первыми заменять конечные элементы пути).

---

## Recur 26
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given. Each internal node of the tree has&nbsp;<i>K</i> (&lt;&nbsp;10) children that are numbered from&nbsp;1 (the most left child) to&nbsp;<i>K</i> (the most right child). The number of the tree root is&nbsp;0. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy the following additional condition: adjacent nodes of the path have different numbers. The order of paths must be the same as in Recur25.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет <i>K</i> (&lt;&nbsp;10) непосредственных потомков (нумеруются от&nbsp;1 до&nbsp;<i>K</i>). Корень дерева имеет номер&nbsp;0. Записать в текстовый файл с данным именем все пути, ведущие от корня к листьям и удовлетворяющие следующему условию: никакие соседние элементы пути не нумеруются одной и той же цифрой. Порядок перебора путей такой же, как в задании Recur25.

---

## Recur 27
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given (<i>N</i>&nbsp;is an even number). Each internal node of the tree has two children; the left child &#34;A&#34; with the weight&nbsp;1 and the right child &#34;B&#34; with the weight&nbsp;&#8722;1. The tree root &#34;C&#34; has the weight&nbsp;0. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy the following additional condition: the total weight of all path nodes is equal to&nbsp;0. The order of paths must be the same as in Recur25.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i> (<i>N</i> &#8212; четное), каждая внутренняя вершина которого имеет 2&nbsp;непосредственных потомка: <i>A</i> с весом&nbsp;1 и&nbsp;<i>B</i> с весом&nbsp;&#8722;1. Корень дерева&nbsp;<i>C</i> имеет вес&nbsp;0. Записать в текстовый файл с данным именем все пути от корня к листьям, удовлетворяющие следующему условию: суммарный вес элементов пути равен&nbsp;0. Порядок перебора путей такой же, как в задании Recur25.

---

## Recur 28
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given; see the description of tree nodes in Recur27. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy the following additional condition: the total weight of any initial part of the path nodes is nonnegative. The order of paths must be the same as in Recur25.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i> того же типа, что и в задании Recur27. Записать в текстовый файл с данным именем все пути от корня к листьям, удовлетворяющие следующему условию: суммарный вес элементов для любого начального отрезка пути неотрицателен. Порядок перебора путей такой же, как в задании Recur25.

---

## Recur 29
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given. Each internal node of the tree has three children; the left child&nbsp;&#34;A&#34; with the weight&nbsp;1, the middle child&nbsp;&#34;B&#34; with the weight&nbsp;0, the right child&nbsp;&#34;C&#34; with the weight&nbsp;&#8722;1. The tree root&nbsp;&#34;D&#34; has the weight&nbsp;0. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy two additional conditions: the total weight of any initial part of the path nodes is nonnegative, and the total weight of all path nodes equals&nbsp;0. The order of paths must be the same as in Recur25.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i>, каждая внутренняя вершина которого имеет 3&nbsp;непосредственных потомка: <i>A</i> с весом&nbsp;1, <i>B</i> с весом&nbsp;0 и&nbsp;<i>C</i> с весом&nbsp;&#8722;1. Корень дерева&nbsp;<i>D</i> имеет вес&nbsp;0. Записать в текстовый файл с данным именем все пути от корня к листьям, удовлетворяющие следующим условиям: суммарный вес элементов для любого начального отрезка пути неположителен, а суммарный вес всех элементов пути равен&nbsp;0. Порядок перебора путей такой же, как в задании Recur25.

---

## Recur 30
#### ![en](https://img.shields.io/badge/EN-blue) A tree of depth&nbsp;<i>N</i> is given; see the description of tree nodes in Recur29. Create a text file (with a given name) whose lines contain paths from the root to all tree leaves; each path must satisfy two additional conditions: adjacent nodes of the path have different letters, and the total weight of all path nodes equals&nbsp;0. The order of paths must be the same as in Recur25.
#### ![ru](https://img.shields.io/badge/RU-blue) Дано дерево глубины&nbsp;<i>N</i> того же типа, что и в задании Recur29. Записать в текстовый файл с данным именем все пути от корня к листьям, удовлетворяющие следующим условиям: никакие соседние элементы пути не обозначаются одной и той же буквой, а суммарный вес всех элементов пути равен&nbsp;0. Порядок перебора путей такой же, как в задании Recur25.

---

